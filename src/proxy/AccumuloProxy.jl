#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING



# types encapsulating arguments and return values of method login

type login_args
  principal::String
  loginProperties::Dict{String,String}
  login_args() = (o=new(); fillunset(o); o)
end # type login_args

type login_result
  success::Vector{UInt8}
  ouch2::AccumuloSecurityException
  login_result() = (o=new(); fillunset(o); o)
  login_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type login_result
meta(t::Type{login_result}) = meta(t, Symbol[:success, :ouch2], Int[0, 1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method addConstraint

type addConstraint_args
  login::Vector{UInt8}
  tableName::String
  constraintClassName::String
  addConstraint_args() = (o=new(); fillunset(o); o)
end # type addConstraint_args

type addConstraint_result
  success::Int32
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  addConstraint_result() = (o=new(); fillunset(o); o)
  addConstraint_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type addConstraint_result
meta(t::Type{addConstraint_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method addSplits

type addSplits_args
  login::Vector{UInt8}
  tableName::String
  splits::Set{Vector{UInt8}}
  addSplits_args() = (o=new(); fillunset(o); o)
end # type addSplits_args

type addSplits_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  addSplits_result() = (o=new(); fillunset(o); o)
end # type addSplits_result
meta(t::Type{addSplits_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method attachIterator

type attachIterator_args
  login::Vector{UInt8}
  tableName::String
  setting::IteratorSetting
  scopes::Set{Int32}
  attachIterator_args() = (o=new(); fillunset(o); o)
end # type attachIterator_args

type attachIterator_result
  ouch1::AccumuloSecurityException
  ouch2::AccumuloException
  ouch3::TableNotFoundException
  attachIterator_result() = (o=new(); fillunset(o); o)
end # type attachIterator_result
meta(t::Type{attachIterator_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method checkIteratorConflicts

type checkIteratorConflicts_args
  login::Vector{UInt8}
  tableName::String
  setting::IteratorSetting
  scopes::Set{Int32}
  checkIteratorConflicts_args() = (o=new(); fillunset(o); o)
end # type checkIteratorConflicts_args

type checkIteratorConflicts_result
  ouch1::AccumuloSecurityException
  ouch2::AccumuloException
  ouch3::TableNotFoundException
  checkIteratorConflicts_result() = (o=new(); fillunset(o); o)
end # type checkIteratorConflicts_result
meta(t::Type{checkIteratorConflicts_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method clearLocatorCache

type clearLocatorCache_args
  login::Vector{UInt8}
  tableName::String
  clearLocatorCache_args() = (o=new(); fillunset(o); o)
end # type clearLocatorCache_args

type clearLocatorCache_result
  ouch1::TableNotFoundException
  clearLocatorCache_result() = (o=new(); fillunset(o); o)
end # type clearLocatorCache_result
meta(t::Type{clearLocatorCache_result}) = meta(t, Symbol[:ouch1], Int[1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method cloneTable

type cloneTable_args
  login::Vector{UInt8}
  tableName::String
  newTableName::String
  flush::Bool
  propertiesToSet::Dict{String,String}
  propertiesToExclude::Set{String}
  cloneTable_args() = (o=new(); fillunset(o); o)
end # type cloneTable_args

type cloneTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  ouch4::TableExistsException
  cloneTable_result() = (o=new(); fillunset(o); o)
end # type cloneTable_result
meta(t::Type{cloneTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method compactTable

type compactTable_args
  login::Vector{UInt8}
  tableName::String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  iterators::Vector{IteratorSetting}
  flush::Bool
  wait::Bool
  compactionStrategy::CompactionStrategyConfig
  compactTable_args() = (o=new(); fillunset(o); o)
end # type compactTable_args

type compactTable_result
  ouch1::AccumuloSecurityException
  ouch2::TableNotFoundException
  ouch3::AccumuloException
  compactTable_result() = (o=new(); fillunset(o); o)
end # type compactTable_result
meta(t::Type{compactTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method cancelCompaction

type cancelCompaction_args
  login::Vector{UInt8}
  tableName::String
  cancelCompaction_args() = (o=new(); fillunset(o); o)
end # type cancelCompaction_args

type cancelCompaction_result
  ouch1::AccumuloSecurityException
  ouch2::TableNotFoundException
  ouch3::AccumuloException
  cancelCompaction_result() = (o=new(); fillunset(o); o)
end # type cancelCompaction_result
meta(t::Type{cancelCompaction_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createTable

type createTable_args
  login::Vector{UInt8}
  tableName::String
  versioningIter::Bool
  _type::Int32
  createTable_args() = (o=new(); fillunset(o); o)
end # type createTable_args

type createTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableExistsException
  createTable_result() = (o=new(); fillunset(o); o)
end # type createTable_result
meta(t::Type{createTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method deleteTable

type deleteTable_args
  login::Vector{UInt8}
  tableName::String
  deleteTable_args() = (o=new(); fillunset(o); o)
end # type deleteTable_args

type deleteTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  deleteTable_result() = (o=new(); fillunset(o); o)
end # type deleteTable_result
meta(t::Type{deleteTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method deleteRows

type deleteRows_args
  login::Vector{UInt8}
  tableName::String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  deleteRows_args() = (o=new(); fillunset(o); o)
end # type deleteRows_args

type deleteRows_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  deleteRows_result() = (o=new(); fillunset(o); o)
end # type deleteRows_result
meta(t::Type{deleteRows_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method exportTable

type exportTable_args
  login::Vector{UInt8}
  tableName::String
  exportDir::String
  exportTable_args() = (o=new(); fillunset(o); o)
end # type exportTable_args

type exportTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  exportTable_result() = (o=new(); fillunset(o); o)
end # type exportTable_result
meta(t::Type{exportTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method flushTable

type flushTable_args
  login::Vector{UInt8}
  tableName::String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  wait::Bool
  flushTable_args() = (o=new(); fillunset(o); o)
end # type flushTable_args

type flushTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  flushTable_result() = (o=new(); fillunset(o); o)
end # type flushTable_result
meta(t::Type{flushTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getDiskUsage

type getDiskUsage_args
  login::Vector{UInt8}
  tables::Set{String}
  getDiskUsage_args() = (o=new(); fillunset(o); o)
end # type getDiskUsage_args

type getDiskUsage_result
  success::Vector{DiskUsage}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getDiskUsage_result() = (o=new(); fillunset(o); o)
  getDiskUsage_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getDiskUsage_result
meta(t::Type{getDiskUsage_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getLocalityGroups

type getLocalityGroups_args
  login::Vector{UInt8}
  tableName::String
  getLocalityGroups_args() = (o=new(); fillunset(o); o)
end # type getLocalityGroups_args

type getLocalityGroups_result
  success::Dict{String,Set{String}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getLocalityGroups_result() = (o=new(); fillunset(o); o)
  getLocalityGroups_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getLocalityGroups_result
meta(t::Type{getLocalityGroups_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getIteratorSetting

type getIteratorSetting_args
  login::Vector{UInt8}
  tableName::String
  iteratorName::String
  scope::Int32
  getIteratorSetting_args() = (o=new(); fillunset(o); o)
end # type getIteratorSetting_args

type getIteratorSetting_result
  success::IteratorSetting
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getIteratorSetting_result() = (o=new(); fillunset(o); o)
  getIteratorSetting_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getIteratorSetting_result
meta(t::Type{getIteratorSetting_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getMaxRow

type getMaxRow_args
  login::Vector{UInt8}
  tableName::String
  auths::Set{Vector{UInt8}}
  startRow::Vector{UInt8}
  startInclusive::Bool
  endRow::Vector{UInt8}
  endInclusive::Bool
  getMaxRow_args() = (o=new(); fillunset(o); o)
end # type getMaxRow_args

type getMaxRow_result
  success::Vector{UInt8}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getMaxRow_result() = (o=new(); fillunset(o); o)
  getMaxRow_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getMaxRow_result
meta(t::Type{getMaxRow_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getTableProperties

type getTableProperties_args
  login::Vector{UInt8}
  tableName::String
  getTableProperties_args() = (o=new(); fillunset(o); o)
end # type getTableProperties_args

type getTableProperties_result
  success::Dict{String,String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getTableProperties_result() = (o=new(); fillunset(o); o)
  getTableProperties_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getTableProperties_result
meta(t::Type{getTableProperties_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method importDirectory

type importDirectory_args
  login::Vector{UInt8}
  tableName::String
  importDir::String
  failureDir::String
  setTime::Bool
  importDirectory_args() = (o=new(); fillunset(o); o)
end # type importDirectory_args

type importDirectory_result
  ouch1::TableNotFoundException
  ouch3::AccumuloException
  ouch4::AccumuloSecurityException
  importDirectory_result() = (o=new(); fillunset(o); o)
end # type importDirectory_result
meta(t::Type{importDirectory_result}) = meta(t, Symbol[:ouch1, :ouch3, :ouch4], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method importTable

type importTable_args
  login::Vector{UInt8}
  tableName::String
  importDir::String
  importTable_args() = (o=new(); fillunset(o); o)
end # type importTable_args

type importTable_result
  ouch1::TableExistsException
  ouch2::AccumuloException
  ouch3::AccumuloSecurityException
  importTable_result() = (o=new(); fillunset(o); o)
end # type importTable_result
meta(t::Type{importTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listSplits

type listSplits_args
  login::Vector{UInt8}
  tableName::String
  maxSplits::Int32
  listSplits_args() = (o=new(); fillunset(o); o)
end # type listSplits_args

type listSplits_result
  success::Vector{Vector{UInt8}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listSplits_result() = (o=new(); fillunset(o); o)
  listSplits_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listSplits_result
meta(t::Type{listSplits_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listTables

type listTables_args
  login::Vector{UInt8}
  listTables_args() = (o=new(); fillunset(o); o)
end # type listTables_args

type listTables_result
  success::Set{String}
  listTables_result() = (o=new(); fillunset(o); o)
  listTables_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listTables_result
meta(t::Type{listTables_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listIterators

type listIterators_args
  login::Vector{UInt8}
  tableName::String
  listIterators_args() = (o=new(); fillunset(o); o)
end # type listIterators_args

type listIterators_result
  success::Dict{String,Set{Int32}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listIterators_result() = (o=new(); fillunset(o); o)
  listIterators_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listIterators_result
meta(t::Type{listIterators_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listConstraints

type listConstraints_args
  login::Vector{UInt8}
  tableName::String
  listConstraints_args() = (o=new(); fillunset(o); o)
end # type listConstraints_args

type listConstraints_result
  success::Dict{String,Int32}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listConstraints_result() = (o=new(); fillunset(o); o)
  listConstraints_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listConstraints_result
meta(t::Type{listConstraints_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method mergeTablets

type mergeTablets_args
  login::Vector{UInt8}
  tableName::String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  mergeTablets_args() = (o=new(); fillunset(o); o)
end # type mergeTablets_args

type mergeTablets_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  mergeTablets_result() = (o=new(); fillunset(o); o)
end # type mergeTablets_result
meta(t::Type{mergeTablets_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method offlineTable

type offlineTable_args
  login::Vector{UInt8}
  tableName::String
  wait::Bool
  offlineTable_args() = (o=new(); fillunset(o); o)
end # type offlineTable_args
meta(t::Type{offlineTable_args}) = meta(t, Symbol[], Int[], Dict{Symbol,Any}(:wait => false))

type offlineTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  offlineTable_result() = (o=new(); fillunset(o); o)
end # type offlineTable_result
meta(t::Type{offlineTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method onlineTable

type onlineTable_args
  login::Vector{UInt8}
  tableName::String
  wait::Bool
  onlineTable_args() = (o=new(); fillunset(o); o)
end # type onlineTable_args
meta(t::Type{onlineTable_args}) = meta(t, Symbol[], Int[], Dict{Symbol,Any}(:wait => false))

type onlineTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  onlineTable_result() = (o=new(); fillunset(o); o)
end # type onlineTable_result
meta(t::Type{onlineTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeConstraint

type removeConstraint_args
  login::Vector{UInt8}
  tableName::String
  constraint::Int32
  removeConstraint_args() = (o=new(); fillunset(o); o)
end # type removeConstraint_args

type removeConstraint_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  removeConstraint_result() = (o=new(); fillunset(o); o)
end # type removeConstraint_result
meta(t::Type{removeConstraint_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeIterator

type removeIterator_args
  login::Vector{UInt8}
  tableName::String
  iterName::String
  scopes::Set{Int32}
  removeIterator_args() = (o=new(); fillunset(o); o)
end # type removeIterator_args

type removeIterator_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  removeIterator_result() = (o=new(); fillunset(o); o)
end # type removeIterator_result
meta(t::Type{removeIterator_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeTableProperty

type removeTableProperty_args
  login::Vector{UInt8}
  tableName::String
  property::String
  removeTableProperty_args() = (o=new(); fillunset(o); o)
end # type removeTableProperty_args

type removeTableProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  removeTableProperty_result() = (o=new(); fillunset(o); o)
end # type removeTableProperty_result
meta(t::Type{removeTableProperty_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method renameTable

type renameTable_args
  login::Vector{UInt8}
  oldTableName::String
  newTableName::String
  renameTable_args() = (o=new(); fillunset(o); o)
end # type renameTable_args

type renameTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  ouch4::TableExistsException
  renameTable_result() = (o=new(); fillunset(o); o)
end # type renameTable_result
meta(t::Type{renameTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method setLocalityGroups

type setLocalityGroups_args
  login::Vector{UInt8}
  tableName::String
  groups::Dict{String,Set{String}}
  setLocalityGroups_args() = (o=new(); fillunset(o); o)
end # type setLocalityGroups_args

type setLocalityGroups_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  setLocalityGroups_result() = (o=new(); fillunset(o); o)
end # type setLocalityGroups_result
meta(t::Type{setLocalityGroups_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method setTableProperty

type setTableProperty_args
  login::Vector{UInt8}
  tableName::String
  property::String
  value::String
  setTableProperty_args() = (o=new(); fillunset(o); o)
end # type setTableProperty_args

type setTableProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  setTableProperty_result() = (o=new(); fillunset(o); o)
end # type setTableProperty_result
meta(t::Type{setTableProperty_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method splitRangeByTablets

type splitRangeByTablets_args
  login::Vector{UInt8}
  tableName::String
  range::Range
  maxSplits::Int32
  splitRangeByTablets_args() = (o=new(); fillunset(o); o)
end # type splitRangeByTablets_args

type splitRangeByTablets_result
  success::Set{Range}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  splitRangeByTablets_result() = (o=new(); fillunset(o); o)
  splitRangeByTablets_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type splitRangeByTablets_result
meta(t::Type{splitRangeByTablets_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method tableExists

type tableExists_args
  login::Vector{UInt8}
  tableName::String
  tableExists_args() = (o=new(); fillunset(o); o)
end # type tableExists_args

type tableExists_result
  success::Bool
  tableExists_result() = (o=new(); fillunset(o); o)
  tableExists_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type tableExists_result
meta(t::Type{tableExists_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method tableIdMap

type tableIdMap_args
  login::Vector{UInt8}
  tableIdMap_args() = (o=new(); fillunset(o); o)
end # type tableIdMap_args

type tableIdMap_result
  success::Dict{String,String}
  tableIdMap_result() = (o=new(); fillunset(o); o)
  tableIdMap_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type tableIdMap_result
meta(t::Type{tableIdMap_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method testTableClassLoad

type testTableClassLoad_args
  login::Vector{UInt8}
  tableName::String
  className::String
  asTypeName::String
  testTableClassLoad_args() = (o=new(); fillunset(o); o)
end # type testTableClassLoad_args

type testTableClassLoad_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  testTableClassLoad_result() = (o=new(); fillunset(o); o)
  testTableClassLoad_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type testTableClassLoad_result
meta(t::Type{testTableClassLoad_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method pingTabletServer

type pingTabletServer_args
  login::Vector{UInt8}
  tserver::String
  pingTabletServer_args() = (o=new(); fillunset(o); o)
end # type pingTabletServer_args

type pingTabletServer_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  pingTabletServer_result() = (o=new(); fillunset(o); o)
end # type pingTabletServer_result
meta(t::Type{pingTabletServer_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getActiveScans

type getActiveScans_args
  login::Vector{UInt8}
  tserver::String
  getActiveScans_args() = (o=new(); fillunset(o); o)
end # type getActiveScans_args

type getActiveScans_result
  success::Vector{ActiveScan}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getActiveScans_result() = (o=new(); fillunset(o); o)
  getActiveScans_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getActiveScans_result
meta(t::Type{getActiveScans_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getActiveCompactions

type getActiveCompactions_args
  login::Vector{UInt8}
  tserver::String
  getActiveCompactions_args() = (o=new(); fillunset(o); o)
end # type getActiveCompactions_args

type getActiveCompactions_result
  success::Vector{ActiveCompaction}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getActiveCompactions_result() = (o=new(); fillunset(o); o)
  getActiveCompactions_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getActiveCompactions_result
meta(t::Type{getActiveCompactions_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getSiteConfiguration

type getSiteConfiguration_args
  login::Vector{UInt8}
  getSiteConfiguration_args() = (o=new(); fillunset(o); o)
end # type getSiteConfiguration_args

type getSiteConfiguration_result
  success::Dict{String,String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getSiteConfiguration_result() = (o=new(); fillunset(o); o)
  getSiteConfiguration_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getSiteConfiguration_result
meta(t::Type{getSiteConfiguration_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getSystemConfiguration

type getSystemConfiguration_args
  login::Vector{UInt8}
  getSystemConfiguration_args() = (o=new(); fillunset(o); o)
end # type getSystemConfiguration_args

type getSystemConfiguration_result
  success::Dict{String,String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getSystemConfiguration_result() = (o=new(); fillunset(o); o)
  getSystemConfiguration_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getSystemConfiguration_result
meta(t::Type{getSystemConfiguration_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getTabletServers

type getTabletServers_args
  login::Vector{UInt8}
  getTabletServers_args() = (o=new(); fillunset(o); o)
end # type getTabletServers_args

type getTabletServers_result
  success::Vector{String}
  getTabletServers_result() = (o=new(); fillunset(o); o)
  getTabletServers_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getTabletServers_result
meta(t::Type{getTabletServers_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeProperty

type removeProperty_args
  login::Vector{UInt8}
  property::String
  removeProperty_args() = (o=new(); fillunset(o); o)
end # type removeProperty_args

type removeProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  removeProperty_result() = (o=new(); fillunset(o); o)
end # type removeProperty_result
meta(t::Type{removeProperty_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method setProperty

type setProperty_args
  login::Vector{UInt8}
  property::String
  value::String
  setProperty_args() = (o=new(); fillunset(o); o)
end # type setProperty_args

type setProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  setProperty_result() = (o=new(); fillunset(o); o)
end # type setProperty_result
meta(t::Type{setProperty_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method testClassLoad

type testClassLoad_args
  login::Vector{UInt8}
  className::String
  asTypeName::String
  testClassLoad_args() = (o=new(); fillunset(o); o)
end # type testClassLoad_args

type testClassLoad_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  testClassLoad_result() = (o=new(); fillunset(o); o)
  testClassLoad_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type testClassLoad_result
meta(t::Type{testClassLoad_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method authenticateUser

type authenticateUser_args
  login::Vector{UInt8}
  user::String
  properties::Dict{String,String}
  authenticateUser_args() = (o=new(); fillunset(o); o)
end # type authenticateUser_args

type authenticateUser_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  authenticateUser_result() = (o=new(); fillunset(o); o)
  authenticateUser_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type authenticateUser_result
meta(t::Type{authenticateUser_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method changeUserAuthorizations

type changeUserAuthorizations_args
  login::Vector{UInt8}
  user::String
  authorizations::Set{Vector{UInt8}}
  changeUserAuthorizations_args() = (o=new(); fillunset(o); o)
end # type changeUserAuthorizations_args

type changeUserAuthorizations_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  changeUserAuthorizations_result() = (o=new(); fillunset(o); o)
end # type changeUserAuthorizations_result
meta(t::Type{changeUserAuthorizations_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method changeLocalUserPassword

type changeLocalUserPassword_args
  login::Vector{UInt8}
  user::String
  password::Vector{UInt8}
  changeLocalUserPassword_args() = (o=new(); fillunset(o); o)
end # type changeLocalUserPassword_args

type changeLocalUserPassword_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  changeLocalUserPassword_result() = (o=new(); fillunset(o); o)
end # type changeLocalUserPassword_result
meta(t::Type{changeLocalUserPassword_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createLocalUser

type createLocalUser_args
  login::Vector{UInt8}
  user::String
  password::Vector{UInt8}
  createLocalUser_args() = (o=new(); fillunset(o); o)
end # type createLocalUser_args

type createLocalUser_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  createLocalUser_result() = (o=new(); fillunset(o); o)
end # type createLocalUser_result
meta(t::Type{createLocalUser_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method dropLocalUser

type dropLocalUser_args
  login::Vector{UInt8}
  user::String
  dropLocalUser_args() = (o=new(); fillunset(o); o)
end # type dropLocalUser_args

type dropLocalUser_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  dropLocalUser_result() = (o=new(); fillunset(o); o)
end # type dropLocalUser_result
meta(t::Type{dropLocalUser_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getUserAuthorizations

type getUserAuthorizations_args
  login::Vector{UInt8}
  user::String
  getUserAuthorizations_args() = (o=new(); fillunset(o); o)
end # type getUserAuthorizations_args

type getUserAuthorizations_result
  success::Vector{Vector{UInt8}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getUserAuthorizations_result() = (o=new(); fillunset(o); o)
  getUserAuthorizations_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getUserAuthorizations_result
meta(t::Type{getUserAuthorizations_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method grantSystemPermission

type grantSystemPermission_args
  login::Vector{UInt8}
  user::String
  perm::Int32
  grantSystemPermission_args() = (o=new(); fillunset(o); o)
end # type grantSystemPermission_args

type grantSystemPermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  grantSystemPermission_result() = (o=new(); fillunset(o); o)
end # type grantSystemPermission_result
meta(t::Type{grantSystemPermission_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method grantTablePermission

type grantTablePermission_args
  login::Vector{UInt8}
  user::String
  table::String
  perm::Int32
  grantTablePermission_args() = (o=new(); fillunset(o); o)
end # type grantTablePermission_args

type grantTablePermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  grantTablePermission_result() = (o=new(); fillunset(o); o)
end # type grantTablePermission_result
meta(t::Type{grantTablePermission_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method hasSystemPermission

type hasSystemPermission_args
  login::Vector{UInt8}
  user::String
  perm::Int32
  hasSystemPermission_args() = (o=new(); fillunset(o); o)
end # type hasSystemPermission_args

type hasSystemPermission_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  hasSystemPermission_result() = (o=new(); fillunset(o); o)
  hasSystemPermission_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type hasSystemPermission_result
meta(t::Type{hasSystemPermission_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method hasTablePermission

type hasTablePermission_args
  login::Vector{UInt8}
  user::String
  table::String
  perm::Int32
  hasTablePermission_args() = (o=new(); fillunset(o); o)
end # type hasTablePermission_args

type hasTablePermission_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  hasTablePermission_result() = (o=new(); fillunset(o); o)
  hasTablePermission_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type hasTablePermission_result
meta(t::Type{hasTablePermission_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listLocalUsers

type listLocalUsers_args
  login::Vector{UInt8}
  listLocalUsers_args() = (o=new(); fillunset(o); o)
end # type listLocalUsers_args

type listLocalUsers_result
  success::Set{String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listLocalUsers_result() = (o=new(); fillunset(o); o)
  listLocalUsers_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listLocalUsers_result
meta(t::Type{listLocalUsers_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method revokeSystemPermission

type revokeSystemPermission_args
  login::Vector{UInt8}
  user::String
  perm::Int32
  revokeSystemPermission_args() = (o=new(); fillunset(o); o)
end # type revokeSystemPermission_args

type revokeSystemPermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  revokeSystemPermission_result() = (o=new(); fillunset(o); o)
end # type revokeSystemPermission_result
meta(t::Type{revokeSystemPermission_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method revokeTablePermission

type revokeTablePermission_args
  login::Vector{UInt8}
  user::String
  table::String
  perm::Int32
  revokeTablePermission_args() = (o=new(); fillunset(o); o)
end # type revokeTablePermission_args

type revokeTablePermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  revokeTablePermission_result() = (o=new(); fillunset(o); o)
end # type revokeTablePermission_result
meta(t::Type{revokeTablePermission_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method grantNamespacePermission

type grantNamespacePermission_args
  login::Vector{UInt8}
  user::String
  namespaceName::String
  perm::Int32
  grantNamespacePermission_args() = (o=new(); fillunset(o); o)
end # type grantNamespacePermission_args

type grantNamespacePermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  grantNamespacePermission_result() = (o=new(); fillunset(o); o)
end # type grantNamespacePermission_result
meta(t::Type{grantNamespacePermission_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method hasNamespacePermission

type hasNamespacePermission_args
  login::Vector{UInt8}
  user::String
  namespaceName::String
  perm::Int32
  hasNamespacePermission_args() = (o=new(); fillunset(o); o)
end # type hasNamespacePermission_args

type hasNamespacePermission_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  hasNamespacePermission_result() = (o=new(); fillunset(o); o)
  hasNamespacePermission_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type hasNamespacePermission_result
meta(t::Type{hasNamespacePermission_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method revokeNamespacePermission

type revokeNamespacePermission_args
  login::Vector{UInt8}
  user::String
  namespaceName::String
  perm::Int32
  revokeNamespacePermission_args() = (o=new(); fillunset(o); o)
end # type revokeNamespacePermission_args

type revokeNamespacePermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  revokeNamespacePermission_result() = (o=new(); fillunset(o); o)
end # type revokeNamespacePermission_result
meta(t::Type{revokeNamespacePermission_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createBatchScanner

type createBatchScanner_args
  login::Vector{UInt8}
  tableName::String
  options::BatchScanOptions
  createBatchScanner_args() = (o=new(); fillunset(o); o)
end # type createBatchScanner_args

type createBatchScanner_result
  success::String
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createBatchScanner_result() = (o=new(); fillunset(o); o)
  createBatchScanner_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createBatchScanner_result
meta(t::Type{createBatchScanner_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createScanner

type createScanner_args
  login::Vector{UInt8}
  tableName::String
  options::ScanOptions
  createScanner_args() = (o=new(); fillunset(o); o)
end # type createScanner_args

type createScanner_result
  success::String
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createScanner_result() = (o=new(); fillunset(o); o)
  createScanner_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createScanner_result
meta(t::Type{createScanner_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method hasNext

type hasNext_args
  scanner::String
  hasNext_args() = (o=new(); fillunset(o); o)
end # type hasNext_args

type hasNext_result
  success::Bool
  ouch1::UnknownScanner
  hasNext_result() = (o=new(); fillunset(o); o)
  hasNext_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type hasNext_result
meta(t::Type{hasNext_result}) = meta(t, Symbol[:success, :ouch1], Int[0, 1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method nextEntry

type nextEntry_args
  scanner::String
  nextEntry_args() = (o=new(); fillunset(o); o)
end # type nextEntry_args

type nextEntry_result
  success::KeyValueAndPeek
  ouch1::NoMoreEntriesException
  ouch2::UnknownScanner
  ouch3::AccumuloSecurityException
  nextEntry_result() = (o=new(); fillunset(o); o)
  nextEntry_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type nextEntry_result
meta(t::Type{nextEntry_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method nextK

type nextK_args
  scanner::String
  k::Int32
  nextK_args() = (o=new(); fillunset(o); o)
end # type nextK_args

type nextK_result
  success::ScanResult
  ouch1::NoMoreEntriesException
  ouch2::UnknownScanner
  ouch3::AccumuloSecurityException
  nextK_result() = (o=new(); fillunset(o); o)
  nextK_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type nextK_result
meta(t::Type{nextK_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method closeScanner

type closeScanner_args
  scanner::String
  closeScanner_args() = (o=new(); fillunset(o); o)
end # type closeScanner_args

type closeScanner_result
  ouch1::UnknownScanner
  closeScanner_result() = (o=new(); fillunset(o); o)
end # type closeScanner_result
meta(t::Type{closeScanner_result}) = meta(t, Symbol[:ouch1], Int[1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method updateAndFlush

type updateAndFlush_args
  login::Vector{UInt8}
  tableName::String
  cells::Dict{Vector{UInt8},Vector{ColumnUpdate}}
  updateAndFlush_args() = (o=new(); fillunset(o); o)
end # type updateAndFlush_args

type updateAndFlush_result
  outch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  ouch4::MutationsRejectedException
  updateAndFlush_result() = (o=new(); fillunset(o); o)
end # type updateAndFlush_result
meta(t::Type{updateAndFlush_result}) = meta(t, Symbol[:outch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createWriter

type createWriter_args
  login::Vector{UInt8}
  tableName::String
  opts::WriterOptions
  createWriter_args() = (o=new(); fillunset(o); o)
end # type createWriter_args

type createWriter_result
  success::String
  outch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createWriter_result() = (o=new(); fillunset(o); o)
  createWriter_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createWriter_result
meta(t::Type{createWriter_result}) = meta(t, Symbol[:success, :outch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method update

type update_args
  writer::String
  cells::Dict{Vector{UInt8},Vector{ColumnUpdate}}
  update_args() = (o=new(); fillunset(o); o)
end # type update_args

# types encapsulating arguments and return values of method flush

type flush_args
  writer::String
  flush_args() = (o=new(); fillunset(o); o)
end # type flush_args

type flush_result
  ouch1::UnknownWriter
  ouch2::MutationsRejectedException
  flush_result() = (o=new(); fillunset(o); o)
end # type flush_result
meta(t::Type{flush_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method closeWriter

type closeWriter_args
  writer::String
  closeWriter_args() = (o=new(); fillunset(o); o)
end # type closeWriter_args

type closeWriter_result
  ouch1::UnknownWriter
  ouch2::MutationsRejectedException
  closeWriter_result() = (o=new(); fillunset(o); o)
end # type closeWriter_result
meta(t::Type{closeWriter_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method updateRowConditionally

type updateRowConditionally_args
  login::Vector{UInt8}
  tableName::String
  row::Vector{UInt8}
  updates::ConditionalUpdates
  updateRowConditionally_args() = (o=new(); fillunset(o); o)
end # type updateRowConditionally_args

type updateRowConditionally_result
  success::Int32
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  updateRowConditionally_result() = (o=new(); fillunset(o); o)
  updateRowConditionally_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type updateRowConditionally_result
meta(t::Type{updateRowConditionally_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createConditionalWriter

type createConditionalWriter_args
  login::Vector{UInt8}
  tableName::String
  options::ConditionalWriterOptions
  createConditionalWriter_args() = (o=new(); fillunset(o); o)
end # type createConditionalWriter_args

type createConditionalWriter_result
  success::String
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createConditionalWriter_result() = (o=new(); fillunset(o); o)
  createConditionalWriter_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createConditionalWriter_result
meta(t::Type{createConditionalWriter_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method updateRowsConditionally

type updateRowsConditionally_args
  conditionalWriter::String
  updates::Dict{Vector{UInt8},ConditionalUpdates}
  updateRowsConditionally_args() = (o=new(); fillunset(o); o)
end # type updateRowsConditionally_args

type updateRowsConditionally_result
  success::Dict{Vector{UInt8},Int32}
  ouch1::UnknownWriter
  ouch2::AccumuloException
  ouch3::AccumuloSecurityException
  updateRowsConditionally_result() = (o=new(); fillunset(o); o)
  updateRowsConditionally_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type updateRowsConditionally_result
meta(t::Type{updateRowsConditionally_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method closeConditionalWriter

type closeConditionalWriter_args
  conditionalWriter::String
  closeConditionalWriter_args() = (o=new(); fillunset(o); o)
end # type closeConditionalWriter_args

type closeConditionalWriter_result
end # type closeConditionalWriter_result
meta(t::Type{closeConditionalWriter_result}) = meta(t, Symbol[], Int[], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getRowRange

type getRowRange_args
  row::Vector{UInt8}
  getRowRange_args() = (o=new(); fillunset(o); o)
end # type getRowRange_args

type getRowRange_result
  success::Range
  getRowRange_result() = (o=new(); fillunset(o); o)
  getRowRange_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getRowRange_result
meta(t::Type{getRowRange_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getFollowing

type getFollowing_args
  key::Key
  part::Int32
  getFollowing_args() = (o=new(); fillunset(o); o)
end # type getFollowing_args

type getFollowing_result
  success::Key
  getFollowing_result() = (o=new(); fillunset(o); o)
  getFollowing_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getFollowing_result
meta(t::Type{getFollowing_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method systemNamespace

type systemNamespace_args
end # type systemNamespace_args

type systemNamespace_result
  success::String
  systemNamespace_result() = (o=new(); fillunset(o); o)
  systemNamespace_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type systemNamespace_result
meta(t::Type{systemNamespace_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method defaultNamespace

type defaultNamespace_args
end # type defaultNamespace_args

type defaultNamespace_result
  success::String
  defaultNamespace_result() = (o=new(); fillunset(o); o)
  defaultNamespace_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type defaultNamespace_result
meta(t::Type{defaultNamespace_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listNamespaces

type listNamespaces_args
  login::Vector{UInt8}
  listNamespaces_args() = (o=new(); fillunset(o); o)
end # type listNamespaces_args

type listNamespaces_result
  success::Vector{String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  listNamespaces_result() = (o=new(); fillunset(o); o)
  listNamespaces_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listNamespaces_result
meta(t::Type{listNamespaces_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method namespaceExists

type namespaceExists_args
  login::Vector{UInt8}
  namespaceName::String
  namespaceExists_args() = (o=new(); fillunset(o); o)
end # type namespaceExists_args

type namespaceExists_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  namespaceExists_result() = (o=new(); fillunset(o); o)
  namespaceExists_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type namespaceExists_result
meta(t::Type{namespaceExists_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createNamespace

type createNamespace_args
  login::Vector{UInt8}
  namespaceName::String
  createNamespace_args() = (o=new(); fillunset(o); o)
end # type createNamespace_args

type createNamespace_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceExistsException
  createNamespace_result() = (o=new(); fillunset(o); o)
end # type createNamespace_result
meta(t::Type{createNamespace_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method deleteNamespace

type deleteNamespace_args
  login::Vector{UInt8}
  namespaceName::String
  deleteNamespace_args() = (o=new(); fillunset(o); o)
end # type deleteNamespace_args

type deleteNamespace_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  ouch4::NamespaceNotEmptyException
  deleteNamespace_result() = (o=new(); fillunset(o); o)
end # type deleteNamespace_result
meta(t::Type{deleteNamespace_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method renameNamespace

type renameNamespace_args
  login::Vector{UInt8}
  oldNamespaceName::String
  newNamespaceName::String
  renameNamespace_args() = (o=new(); fillunset(o); o)
end # type renameNamespace_args

type renameNamespace_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  ouch4::NamespaceExistsException
  renameNamespace_result() = (o=new(); fillunset(o); o)
end # type renameNamespace_result
meta(t::Type{renameNamespace_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method setNamespaceProperty

type setNamespaceProperty_args
  login::Vector{UInt8}
  namespaceName::String
  property::String
  value::String
  setNamespaceProperty_args() = (o=new(); fillunset(o); o)
end # type setNamespaceProperty_args

type setNamespaceProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  setNamespaceProperty_result() = (o=new(); fillunset(o); o)
end # type setNamespaceProperty_result
meta(t::Type{setNamespaceProperty_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeNamespaceProperty

type removeNamespaceProperty_args
  login::Vector{UInt8}
  namespaceName::String
  property::String
  removeNamespaceProperty_args() = (o=new(); fillunset(o); o)
end # type removeNamespaceProperty_args

type removeNamespaceProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  removeNamespaceProperty_result() = (o=new(); fillunset(o); o)
end # type removeNamespaceProperty_result
meta(t::Type{removeNamespaceProperty_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getNamespaceProperties

type getNamespaceProperties_args
  login::Vector{UInt8}
  namespaceName::String
  getNamespaceProperties_args() = (o=new(); fillunset(o); o)
end # type getNamespaceProperties_args

type getNamespaceProperties_result
  success::Dict{String,String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  getNamespaceProperties_result() = (o=new(); fillunset(o); o)
  getNamespaceProperties_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getNamespaceProperties_result
meta(t::Type{getNamespaceProperties_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method namespaceIdMap

type namespaceIdMap_args
  login::Vector{UInt8}
  namespaceIdMap_args() = (o=new(); fillunset(o); o)
end # type namespaceIdMap_args

type namespaceIdMap_result
  success::Dict{String,String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  namespaceIdMap_result() = (o=new(); fillunset(o); o)
  namespaceIdMap_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type namespaceIdMap_result
meta(t::Type{namespaceIdMap_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method attachNamespaceIterator

type attachNamespaceIterator_args
  login::Vector{UInt8}
  namespaceName::String
  setting::IteratorSetting
  scopes::Set{Int32}
  attachNamespaceIterator_args() = (o=new(); fillunset(o); o)
end # type attachNamespaceIterator_args

type attachNamespaceIterator_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  attachNamespaceIterator_result() = (o=new(); fillunset(o); o)
end # type attachNamespaceIterator_result
meta(t::Type{attachNamespaceIterator_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeNamespaceIterator

type removeNamespaceIterator_args
  login::Vector{UInt8}
  namespaceName::String
  name::String
  scopes::Set{Int32}
  removeNamespaceIterator_args() = (o=new(); fillunset(o); o)
end # type removeNamespaceIterator_args

type removeNamespaceIterator_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  removeNamespaceIterator_result() = (o=new(); fillunset(o); o)
end # type removeNamespaceIterator_result
meta(t::Type{removeNamespaceIterator_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getNamespaceIteratorSetting

type getNamespaceIteratorSetting_args
  login::Vector{UInt8}
  namespaceName::String
  name::String
  scope::Int32
  getNamespaceIteratorSetting_args() = (o=new(); fillunset(o); o)
end # type getNamespaceIteratorSetting_args

type getNamespaceIteratorSetting_result
  success::IteratorSetting
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  getNamespaceIteratorSetting_result() = (o=new(); fillunset(o); o)
  getNamespaceIteratorSetting_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getNamespaceIteratorSetting_result
meta(t::Type{getNamespaceIteratorSetting_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listNamespaceIterators

type listNamespaceIterators_args
  login::Vector{UInt8}
  namespaceName::String
  listNamespaceIterators_args() = (o=new(); fillunset(o); o)
end # type listNamespaceIterators_args

type listNamespaceIterators_result
  success::Dict{String,Set{Int32}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  listNamespaceIterators_result() = (o=new(); fillunset(o); o)
  listNamespaceIterators_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listNamespaceIterators_result
meta(t::Type{listNamespaceIterators_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method checkNamespaceIteratorConflicts

type checkNamespaceIteratorConflicts_args
  login::Vector{UInt8}
  namespaceName::String
  setting::IteratorSetting
  scopes::Set{Int32}
  checkNamespaceIteratorConflicts_args() = (o=new(); fillunset(o); o)
end # type checkNamespaceIteratorConflicts_args

type checkNamespaceIteratorConflicts_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  checkNamespaceIteratorConflicts_result() = (o=new(); fillunset(o); o)
end # type checkNamespaceIteratorConflicts_result
meta(t::Type{checkNamespaceIteratorConflicts_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method addNamespaceConstraint

type addNamespaceConstraint_args
  login::Vector{UInt8}
  namespaceName::String
  constraintClassName::String
  addNamespaceConstraint_args() = (o=new(); fillunset(o); o)
end # type addNamespaceConstraint_args

type addNamespaceConstraint_result
  success::Int32
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  addNamespaceConstraint_result() = (o=new(); fillunset(o); o)
  addNamespaceConstraint_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type addNamespaceConstraint_result
meta(t::Type{addNamespaceConstraint_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeNamespaceConstraint

type removeNamespaceConstraint_args
  login::Vector{UInt8}
  namespaceName::String
  id::Int32
  removeNamespaceConstraint_args() = (o=new(); fillunset(o); o)
end # type removeNamespaceConstraint_args

type removeNamespaceConstraint_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  removeNamespaceConstraint_result() = (o=new(); fillunset(o); o)
end # type removeNamespaceConstraint_result
meta(t::Type{removeNamespaceConstraint_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listNamespaceConstraints

type listNamespaceConstraints_args
  login::Vector{UInt8}
  namespaceName::String
  listNamespaceConstraints_args() = (o=new(); fillunset(o); o)
end # type listNamespaceConstraints_args

type listNamespaceConstraints_result
  success::Dict{String,Int32}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  listNamespaceConstraints_result() = (o=new(); fillunset(o); o)
  listNamespaceConstraints_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listNamespaceConstraints_result
meta(t::Type{listNamespaceConstraints_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method testNamespaceClassLoad

type testNamespaceClassLoad_args
  login::Vector{UInt8}
  namespaceName::String
  className::String
  asTypeName::String
  testNamespaceClassLoad_args() = (o=new(); fillunset(o); o)
end # type testNamespaceClassLoad_args

type testNamespaceClassLoad_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::NamespaceNotFoundException
  testNamespaceClassLoad_result() = (o=new(); fillunset(o); o)
  testNamespaceClassLoad_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type testNamespaceClassLoad_result
meta(t::Type{testNamespaceClassLoad_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())



# Processor for AccumuloProxy service (to be used in server implementation)
type AccumuloProxyProcessor <: TProcessor
  tp::ThriftProcessor
  function AccumuloProxyProcessor()
    p = new(ThriftProcessor())
    handle(p.tp, ThriftHandler("login", _login, login_args, login_result))
    handle(p.tp, ThriftHandler("addConstraint", _addConstraint, addConstraint_args, addConstraint_result))
    handle(p.tp, ThriftHandler("addSplits", _addSplits, addSplits_args, addSplits_result))
    handle(p.tp, ThriftHandler("attachIterator", _attachIterator, attachIterator_args, attachIterator_result))
    handle(p.tp, ThriftHandler("checkIteratorConflicts", _checkIteratorConflicts, checkIteratorConflicts_args, checkIteratorConflicts_result))
    handle(p.tp, ThriftHandler("clearLocatorCache", _clearLocatorCache, clearLocatorCache_args, clearLocatorCache_result))
    handle(p.tp, ThriftHandler("cloneTable", _cloneTable, cloneTable_args, cloneTable_result))
    handle(p.tp, ThriftHandler("compactTable", _compactTable, compactTable_args, compactTable_result))
    handle(p.tp, ThriftHandler("cancelCompaction", _cancelCompaction, cancelCompaction_args, cancelCompaction_result))
    handle(p.tp, ThriftHandler("createTable", _createTable, createTable_args, createTable_result))
    handle(p.tp, ThriftHandler("deleteTable", _deleteTable, deleteTable_args, deleteTable_result))
    handle(p.tp, ThriftHandler("deleteRows", _deleteRows, deleteRows_args, deleteRows_result))
    handle(p.tp, ThriftHandler("exportTable", _exportTable, exportTable_args, exportTable_result))
    handle(p.tp, ThriftHandler("flushTable", _flushTable, flushTable_args, flushTable_result))
    handle(p.tp, ThriftHandler("getDiskUsage", _getDiskUsage, getDiskUsage_args, getDiskUsage_result))
    handle(p.tp, ThriftHandler("getLocalityGroups", _getLocalityGroups, getLocalityGroups_args, getLocalityGroups_result))
    handle(p.tp, ThriftHandler("getIteratorSetting", _getIteratorSetting, getIteratorSetting_args, getIteratorSetting_result))
    handle(p.tp, ThriftHandler("getMaxRow", _getMaxRow, getMaxRow_args, getMaxRow_result))
    handle(p.tp, ThriftHandler("getTableProperties", _getTableProperties, getTableProperties_args, getTableProperties_result))
    handle(p.tp, ThriftHandler("importDirectory", _importDirectory, importDirectory_args, importDirectory_result))
    handle(p.tp, ThriftHandler("importTable", _importTable, importTable_args, importTable_result))
    handle(p.tp, ThriftHandler("listSplits", _listSplits, listSplits_args, listSplits_result))
    handle(p.tp, ThriftHandler("listTables", _listTables, listTables_args, listTables_result))
    handle(p.tp, ThriftHandler("listIterators", _listIterators, listIterators_args, listIterators_result))
    handle(p.tp, ThriftHandler("listConstraints", _listConstraints, listConstraints_args, listConstraints_result))
    handle(p.tp, ThriftHandler("mergeTablets", _mergeTablets, mergeTablets_args, mergeTablets_result))
    handle(p.tp, ThriftHandler("offlineTable", _offlineTable, offlineTable_args, offlineTable_result))
    handle(p.tp, ThriftHandler("onlineTable", _onlineTable, onlineTable_args, onlineTable_result))
    handle(p.tp, ThriftHandler("removeConstraint", _removeConstraint, removeConstraint_args, removeConstraint_result))
    handle(p.tp, ThriftHandler("removeIterator", _removeIterator, removeIterator_args, removeIterator_result))
    handle(p.tp, ThriftHandler("removeTableProperty", _removeTableProperty, removeTableProperty_args, removeTableProperty_result))
    handle(p.tp, ThriftHandler("renameTable", _renameTable, renameTable_args, renameTable_result))
    handle(p.tp, ThriftHandler("setLocalityGroups", _setLocalityGroups, setLocalityGroups_args, setLocalityGroups_result))
    handle(p.tp, ThriftHandler("setTableProperty", _setTableProperty, setTableProperty_args, setTableProperty_result))
    handle(p.tp, ThriftHandler("splitRangeByTablets", _splitRangeByTablets, splitRangeByTablets_args, splitRangeByTablets_result))
    handle(p.tp, ThriftHandler("tableExists", _tableExists, tableExists_args, tableExists_result))
    handle(p.tp, ThriftHandler("tableIdMap", _tableIdMap, tableIdMap_args, tableIdMap_result))
    handle(p.tp, ThriftHandler("testTableClassLoad", _testTableClassLoad, testTableClassLoad_args, testTableClassLoad_result))
    handle(p.tp, ThriftHandler("pingTabletServer", _pingTabletServer, pingTabletServer_args, pingTabletServer_result))
    handle(p.tp, ThriftHandler("getActiveScans", _getActiveScans, getActiveScans_args, getActiveScans_result))
    handle(p.tp, ThriftHandler("getActiveCompactions", _getActiveCompactions, getActiveCompactions_args, getActiveCompactions_result))
    handle(p.tp, ThriftHandler("getSiteConfiguration", _getSiteConfiguration, getSiteConfiguration_args, getSiteConfiguration_result))
    handle(p.tp, ThriftHandler("getSystemConfiguration", _getSystemConfiguration, getSystemConfiguration_args, getSystemConfiguration_result))
    handle(p.tp, ThriftHandler("getTabletServers", _getTabletServers, getTabletServers_args, getTabletServers_result))
    handle(p.tp, ThriftHandler("removeProperty", _removeProperty, removeProperty_args, removeProperty_result))
    handle(p.tp, ThriftHandler("setProperty", _setProperty, setProperty_args, setProperty_result))
    handle(p.tp, ThriftHandler("testClassLoad", _testClassLoad, testClassLoad_args, testClassLoad_result))
    handle(p.tp, ThriftHandler("authenticateUser", _authenticateUser, authenticateUser_args, authenticateUser_result))
    handle(p.tp, ThriftHandler("changeUserAuthorizations", _changeUserAuthorizations, changeUserAuthorizations_args, changeUserAuthorizations_result))
    handle(p.tp, ThriftHandler("changeLocalUserPassword", _changeLocalUserPassword, changeLocalUserPassword_args, changeLocalUserPassword_result))
    handle(p.tp, ThriftHandler("createLocalUser", _createLocalUser, createLocalUser_args, createLocalUser_result))
    handle(p.tp, ThriftHandler("dropLocalUser", _dropLocalUser, dropLocalUser_args, dropLocalUser_result))
    handle(p.tp, ThriftHandler("getUserAuthorizations", _getUserAuthorizations, getUserAuthorizations_args, getUserAuthorizations_result))
    handle(p.tp, ThriftHandler("grantSystemPermission", _grantSystemPermission, grantSystemPermission_args, grantSystemPermission_result))
    handle(p.tp, ThriftHandler("grantTablePermission", _grantTablePermission, grantTablePermission_args, grantTablePermission_result))
    handle(p.tp, ThriftHandler("hasSystemPermission", _hasSystemPermission, hasSystemPermission_args, hasSystemPermission_result))
    handle(p.tp, ThriftHandler("hasTablePermission", _hasTablePermission, hasTablePermission_args, hasTablePermission_result))
    handle(p.tp, ThriftHandler("listLocalUsers", _listLocalUsers, listLocalUsers_args, listLocalUsers_result))
    handle(p.tp, ThriftHandler("revokeSystemPermission", _revokeSystemPermission, revokeSystemPermission_args, revokeSystemPermission_result))
    handle(p.tp, ThriftHandler("revokeTablePermission", _revokeTablePermission, revokeTablePermission_args, revokeTablePermission_result))
    handle(p.tp, ThriftHandler("grantNamespacePermission", _grantNamespacePermission, grantNamespacePermission_args, grantNamespacePermission_result))
    handle(p.tp, ThriftHandler("hasNamespacePermission", _hasNamespacePermission, hasNamespacePermission_args, hasNamespacePermission_result))
    handle(p.tp, ThriftHandler("revokeNamespacePermission", _revokeNamespacePermission, revokeNamespacePermission_args, revokeNamespacePermission_result))
    handle(p.tp, ThriftHandler("createBatchScanner", _createBatchScanner, createBatchScanner_args, createBatchScanner_result))
    handle(p.tp, ThriftHandler("createScanner", _createScanner, createScanner_args, createScanner_result))
    handle(p.tp, ThriftHandler("hasNext", _hasNext, hasNext_args, hasNext_result))
    handle(p.tp, ThriftHandler("nextEntry", _nextEntry, nextEntry_args, nextEntry_result))
    handle(p.tp, ThriftHandler("nextK", _nextK, nextK_args, nextK_result))
    handle(p.tp, ThriftHandler("closeScanner", _closeScanner, closeScanner_args, closeScanner_result))
    handle(p.tp, ThriftHandler("updateAndFlush", _updateAndFlush, updateAndFlush_args, updateAndFlush_result))
    handle(p.tp, ThriftHandler("createWriter", _createWriter, createWriter_args, createWriter_result))
    handle(p.tp, ThriftHandler("update", _update, update_args, Void))
    handle(p.tp, ThriftHandler("flush", _flush, flush_args, flush_result))
    handle(p.tp, ThriftHandler("closeWriter", _closeWriter, closeWriter_args, closeWriter_result))
    handle(p.tp, ThriftHandler("updateRowConditionally", _updateRowConditionally, updateRowConditionally_args, updateRowConditionally_result))
    handle(p.tp, ThriftHandler("createConditionalWriter", _createConditionalWriter, createConditionalWriter_args, createConditionalWriter_result))
    handle(p.tp, ThriftHandler("updateRowsConditionally", _updateRowsConditionally, updateRowsConditionally_args, updateRowsConditionally_result))
    handle(p.tp, ThriftHandler("closeConditionalWriter", _closeConditionalWriter, closeConditionalWriter_args, closeConditionalWriter_result))
    handle(p.tp, ThriftHandler("getRowRange", _getRowRange, getRowRange_args, getRowRange_result))
    handle(p.tp, ThriftHandler("getFollowing", _getFollowing, getFollowing_args, getFollowing_result))
    handle(p.tp, ThriftHandler("systemNamespace", _systemNamespace, systemNamespace_args, systemNamespace_result))
    handle(p.tp, ThriftHandler("defaultNamespace", _defaultNamespace, defaultNamespace_args, defaultNamespace_result))
    handle(p.tp, ThriftHandler("listNamespaces", _listNamespaces, listNamespaces_args, listNamespaces_result))
    handle(p.tp, ThriftHandler("namespaceExists", _namespaceExists, namespaceExists_args, namespaceExists_result))
    handle(p.tp, ThriftHandler("createNamespace", _createNamespace, createNamespace_args, createNamespace_result))
    handle(p.tp, ThriftHandler("deleteNamespace", _deleteNamespace, deleteNamespace_args, deleteNamespace_result))
    handle(p.tp, ThriftHandler("renameNamespace", _renameNamespace, renameNamespace_args, renameNamespace_result))
    handle(p.tp, ThriftHandler("setNamespaceProperty", _setNamespaceProperty, setNamespaceProperty_args, setNamespaceProperty_result))
    handle(p.tp, ThriftHandler("removeNamespaceProperty", _removeNamespaceProperty, removeNamespaceProperty_args, removeNamespaceProperty_result))
    handle(p.tp, ThriftHandler("getNamespaceProperties", _getNamespaceProperties, getNamespaceProperties_args, getNamespaceProperties_result))
    handle(p.tp, ThriftHandler("namespaceIdMap", _namespaceIdMap, namespaceIdMap_args, namespaceIdMap_result))
    handle(p.tp, ThriftHandler("attachNamespaceIterator", _attachNamespaceIterator, attachNamespaceIterator_args, attachNamespaceIterator_result))
    handle(p.tp, ThriftHandler("removeNamespaceIterator", _removeNamespaceIterator, removeNamespaceIterator_args, removeNamespaceIterator_result))
    handle(p.tp, ThriftHandler("getNamespaceIteratorSetting", _getNamespaceIteratorSetting, getNamespaceIteratorSetting_args, getNamespaceIteratorSetting_result))
    handle(p.tp, ThriftHandler("listNamespaceIterators", _listNamespaceIterators, listNamespaceIterators_args, listNamespaceIterators_result))
    handle(p.tp, ThriftHandler("checkNamespaceIteratorConflicts", _checkNamespaceIteratorConflicts, checkNamespaceIteratorConflicts_args, checkNamespaceIteratorConflicts_result))
    handle(p.tp, ThriftHandler("addNamespaceConstraint", _addNamespaceConstraint, addNamespaceConstraint_args, addNamespaceConstraint_result))
    handle(p.tp, ThriftHandler("removeNamespaceConstraint", _removeNamespaceConstraint, removeNamespaceConstraint_args, removeNamespaceConstraint_result))
    handle(p.tp, ThriftHandler("listNamespaceConstraints", _listNamespaceConstraints, listNamespaceConstraints_args, listNamespaceConstraints_result))
    handle(p.tp, ThriftHandler("testNamespaceClassLoad", _testNamespaceClassLoad, testNamespaceClassLoad_args, testNamespaceClassLoad_result))
    p
  end
  function _login(inp::login_args)
    try
      result = login(inp.principal, inp.loginProperties)
      return login_result(result)
    catch ex
      exret = login_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _login
  function _addConstraint(inp::addConstraint_args)
    try
      result = addConstraint(inp.login, inp.tableName, inp.constraintClassName)
      return addConstraint_result(result)
    catch ex
      exret = addConstraint_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _addConstraint
  function _addSplits(inp::addSplits_args)
    try
      addSplits(inp.login, inp.tableName, inp.splits)
      return addSplits_result()
    catch ex
      exret = addSplits_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _addSplits
  function _attachIterator(inp::attachIterator_args)
    try
      attachIterator(inp.login, inp.tableName, inp.setting, inp.scopes)
      return attachIterator_result()
    catch ex
      exret = attachIterator_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _attachIterator
  function _checkIteratorConflicts(inp::checkIteratorConflicts_args)
    try
      checkIteratorConflicts(inp.login, inp.tableName, inp.setting, inp.scopes)
      return checkIteratorConflicts_result()
    catch ex
      exret = checkIteratorConflicts_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _checkIteratorConflicts
  function _clearLocatorCache(inp::clearLocatorCache_args)
    try
      clearLocatorCache(inp.login, inp.tableName)
      return clearLocatorCache_result()
    catch ex
      exret = clearLocatorCache_result()
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch1, ex); return exret)
      rethrow()
    end # try
  end #function _clearLocatorCache
  function _cloneTable(inp::cloneTable_args)
    try
      cloneTable(inp.login, inp.tableName, inp.newTableName, inp.flush, inp.propertiesToSet, inp.propertiesToExclude)
      return cloneTable_result()
    catch ex
      exret = cloneTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, TableExistsException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _cloneTable
  function _compactTable(inp::compactTable_args)
    try
      compactTable(inp.login, inp.tableName, inp.startRow, inp.endRow, inp.iterators, inp.flush, inp.wait, inp.compactionStrategy)
      return compactTable_result()
    catch ex
      exret = compactTable_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _compactTable
  function _cancelCompaction(inp::cancelCompaction_args)
    try
      cancelCompaction(inp.login, inp.tableName)
      return cancelCompaction_result()
    catch ex
      exret = cancelCompaction_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _cancelCompaction
  function _createTable(inp::createTable_args)
    try
      createTable(inp.login, inp.tableName, inp.versioningIter, inp._type)
      return createTable_result()
    catch ex
      exret = createTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableExistsException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createTable
  function _deleteTable(inp::deleteTable_args)
    try
      deleteTable(inp.login, inp.tableName)
      return deleteTable_result()
    catch ex
      exret = deleteTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _deleteTable
  function _deleteRows(inp::deleteRows_args)
    try
      deleteRows(inp.login, inp.tableName, inp.startRow, inp.endRow)
      return deleteRows_result()
    catch ex
      exret = deleteRows_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _deleteRows
  function _exportTable(inp::exportTable_args)
    try
      exportTable(inp.login, inp.tableName, inp.exportDir)
      return exportTable_result()
    catch ex
      exret = exportTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _exportTable
  function _flushTable(inp::flushTable_args)
    try
      flushTable(inp.login, inp.tableName, inp.startRow, inp.endRow, inp.wait)
      return flushTable_result()
    catch ex
      exret = flushTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _flushTable
  function _getDiskUsage(inp::getDiskUsage_args)
    try
      result = getDiskUsage(inp.login, inp.tables)
      return getDiskUsage_result(result)
    catch ex
      exret = getDiskUsage_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getDiskUsage
  function _getLocalityGroups(inp::getLocalityGroups_args)
    try
      result = getLocalityGroups(inp.login, inp.tableName)
      return getLocalityGroups_result(result)
    catch ex
      exret = getLocalityGroups_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getLocalityGroups
  function _getIteratorSetting(inp::getIteratorSetting_args)
    try
      result = getIteratorSetting(inp.login, inp.tableName, inp.iteratorName, inp.scope)
      return getIteratorSetting_result(result)
    catch ex
      exret = getIteratorSetting_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getIteratorSetting
  function _getMaxRow(inp::getMaxRow_args)
    try
      result = getMaxRow(inp.login, inp.tableName, inp.auths, inp.startRow, inp.startInclusive, inp.endRow, inp.endInclusive)
      return getMaxRow_result(result)
    catch ex
      exret = getMaxRow_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getMaxRow
  function _getTableProperties(inp::getTableProperties_args)
    try
      result = getTableProperties(inp.login, inp.tableName)
      return getTableProperties_result(result)
    catch ex
      exret = getTableProperties_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getTableProperties
  function _importDirectory(inp::importDirectory_args)
    try
      importDirectory(inp.login, inp.tableName, inp.importDir, inp.failureDir, inp.setTime)
      return importDirectory_result()
    catch ex
      exret = importDirectory_result()
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _importDirectory
  function _importTable(inp::importTable_args)
    try
      importTable(inp.login, inp.tableName, inp.importDir)
      return importTable_result()
    catch ex
      exret = importTable_result()
      isa(ex, TableExistsException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _importTable
  function _listSplits(inp::listSplits_args)
    try
      result = listSplits(inp.login, inp.tableName, inp.maxSplits)
      return listSplits_result(result)
    catch ex
      exret = listSplits_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listSplits
  _listTables(inp::listTables_args) = listTables_result(listTables(inp.login))
  function _listIterators(inp::listIterators_args)
    try
      result = listIterators(inp.login, inp.tableName)
      return listIterators_result(result)
    catch ex
      exret = listIterators_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listIterators
  function _listConstraints(inp::listConstraints_args)
    try
      result = listConstraints(inp.login, inp.tableName)
      return listConstraints_result(result)
    catch ex
      exret = listConstraints_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listConstraints
  function _mergeTablets(inp::mergeTablets_args)
    try
      mergeTablets(inp.login, inp.tableName, inp.startRow, inp.endRow)
      return mergeTablets_result()
    catch ex
      exret = mergeTablets_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _mergeTablets
  function _offlineTable(inp::offlineTable_args)
    try
      offlineTable(inp.login, inp.tableName, inp.wait)
      return offlineTable_result()
    catch ex
      exret = offlineTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _offlineTable
  function _onlineTable(inp::onlineTable_args)
    try
      onlineTable(inp.login, inp.tableName, inp.wait)
      return onlineTable_result()
    catch ex
      exret = onlineTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _onlineTable
  function _removeConstraint(inp::removeConstraint_args)
    try
      removeConstraint(inp.login, inp.tableName, inp.constraint)
      return removeConstraint_result()
    catch ex
      exret = removeConstraint_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeConstraint
  function _removeIterator(inp::removeIterator_args)
    try
      removeIterator(inp.login, inp.tableName, inp.iterName, inp.scopes)
      return removeIterator_result()
    catch ex
      exret = removeIterator_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeIterator
  function _removeTableProperty(inp::removeTableProperty_args)
    try
      removeTableProperty(inp.login, inp.tableName, inp.property)
      return removeTableProperty_result()
    catch ex
      exret = removeTableProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeTableProperty
  function _renameTable(inp::renameTable_args)
    try
      renameTable(inp.login, inp.oldTableName, inp.newTableName)
      return renameTable_result()
    catch ex
      exret = renameTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, TableExistsException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _renameTable
  function _setLocalityGroups(inp::setLocalityGroups_args)
    try
      setLocalityGroups(inp.login, inp.tableName, inp.groups)
      return setLocalityGroups_result()
    catch ex
      exret = setLocalityGroups_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _setLocalityGroups
  function _setTableProperty(inp::setTableProperty_args)
    try
      setTableProperty(inp.login, inp.tableName, inp.property, inp.value)
      return setTableProperty_result()
    catch ex
      exret = setTableProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _setTableProperty
  function _splitRangeByTablets(inp::splitRangeByTablets_args)
    try
      result = splitRangeByTablets(inp.login, inp.tableName, inp.range, inp.maxSplits)
      return splitRangeByTablets_result(result)
    catch ex
      exret = splitRangeByTablets_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _splitRangeByTablets
  _tableExists(inp::tableExists_args) = tableExists_result(tableExists(inp.login, inp.tableName))
  _tableIdMap(inp::tableIdMap_args) = tableIdMap_result(tableIdMap(inp.login))
  function _testTableClassLoad(inp::testTableClassLoad_args)
    try
      result = testTableClassLoad(inp.login, inp.tableName, inp.className, inp.asTypeName)
      return testTableClassLoad_result(result)
    catch ex
      exret = testTableClassLoad_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _testTableClassLoad
  function _pingTabletServer(inp::pingTabletServer_args)
    try
      pingTabletServer(inp.login, inp.tserver)
      return pingTabletServer_result()
    catch ex
      exret = pingTabletServer_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _pingTabletServer
  function _getActiveScans(inp::getActiveScans_args)
    try
      result = getActiveScans(inp.login, inp.tserver)
      return getActiveScans_result(result)
    catch ex
      exret = getActiveScans_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getActiveScans
  function _getActiveCompactions(inp::getActiveCompactions_args)
    try
      result = getActiveCompactions(inp.login, inp.tserver)
      return getActiveCompactions_result(result)
    catch ex
      exret = getActiveCompactions_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getActiveCompactions
  function _getSiteConfiguration(inp::getSiteConfiguration_args)
    try
      result = getSiteConfiguration(inp.login)
      return getSiteConfiguration_result(result)
    catch ex
      exret = getSiteConfiguration_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getSiteConfiguration
  function _getSystemConfiguration(inp::getSystemConfiguration_args)
    try
      result = getSystemConfiguration(inp.login)
      return getSystemConfiguration_result(result)
    catch ex
      exret = getSystemConfiguration_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getSystemConfiguration
  _getTabletServers(inp::getTabletServers_args) = getTabletServers_result(getTabletServers(inp.login))
  function _removeProperty(inp::removeProperty_args)
    try
      removeProperty(inp.login, inp.property)
      return removeProperty_result()
    catch ex
      exret = removeProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _removeProperty
  function _setProperty(inp::setProperty_args)
    try
      setProperty(inp.login, inp.property, inp.value)
      return setProperty_result()
    catch ex
      exret = setProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _setProperty
  function _testClassLoad(inp::testClassLoad_args)
    try
      result = testClassLoad(inp.login, inp.className, inp.asTypeName)
      return testClassLoad_result(result)
    catch ex
      exret = testClassLoad_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _testClassLoad
  function _authenticateUser(inp::authenticateUser_args)
    try
      result = authenticateUser(inp.login, inp.user, inp.properties)
      return authenticateUser_result(result)
    catch ex
      exret = authenticateUser_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _authenticateUser
  function _changeUserAuthorizations(inp::changeUserAuthorizations_args)
    try
      changeUserAuthorizations(inp.login, inp.user, inp.authorizations)
      return changeUserAuthorizations_result()
    catch ex
      exret = changeUserAuthorizations_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _changeUserAuthorizations
  function _changeLocalUserPassword(inp::changeLocalUserPassword_args)
    try
      changeLocalUserPassword(inp.login, inp.user, inp.password)
      return changeLocalUserPassword_result()
    catch ex
      exret = changeLocalUserPassword_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _changeLocalUserPassword
  function _createLocalUser(inp::createLocalUser_args)
    try
      createLocalUser(inp.login, inp.user, inp.password)
      return createLocalUser_result()
    catch ex
      exret = createLocalUser_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _createLocalUser
  function _dropLocalUser(inp::dropLocalUser_args)
    try
      dropLocalUser(inp.login, inp.user)
      return dropLocalUser_result()
    catch ex
      exret = dropLocalUser_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _dropLocalUser
  function _getUserAuthorizations(inp::getUserAuthorizations_args)
    try
      result = getUserAuthorizations(inp.login, inp.user)
      return getUserAuthorizations_result(result)
    catch ex
      exret = getUserAuthorizations_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getUserAuthorizations
  function _grantSystemPermission(inp::grantSystemPermission_args)
    try
      grantSystemPermission(inp.login, inp.user, inp.perm)
      return grantSystemPermission_result()
    catch ex
      exret = grantSystemPermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _grantSystemPermission
  function _grantTablePermission(inp::grantTablePermission_args)
    try
      grantTablePermission(inp.login, inp.user, inp.table, inp.perm)
      return grantTablePermission_result()
    catch ex
      exret = grantTablePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _grantTablePermission
  function _hasSystemPermission(inp::hasSystemPermission_args)
    try
      result = hasSystemPermission(inp.login, inp.user, inp.perm)
      return hasSystemPermission_result(result)
    catch ex
      exret = hasSystemPermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _hasSystemPermission
  function _hasTablePermission(inp::hasTablePermission_args)
    try
      result = hasTablePermission(inp.login, inp.user, inp.table, inp.perm)
      return hasTablePermission_result(result)
    catch ex
      exret = hasTablePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _hasTablePermission
  function _listLocalUsers(inp::listLocalUsers_args)
    try
      result = listLocalUsers(inp.login)
      return listLocalUsers_result(result)
    catch ex
      exret = listLocalUsers_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listLocalUsers
  function _revokeSystemPermission(inp::revokeSystemPermission_args)
    try
      revokeSystemPermission(inp.login, inp.user, inp.perm)
      return revokeSystemPermission_result()
    catch ex
      exret = revokeSystemPermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _revokeSystemPermission
  function _revokeTablePermission(inp::revokeTablePermission_args)
    try
      revokeTablePermission(inp.login, inp.user, inp.table, inp.perm)
      return revokeTablePermission_result()
    catch ex
      exret = revokeTablePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _revokeTablePermission
  function _grantNamespacePermission(inp::grantNamespacePermission_args)
    try
      grantNamespacePermission(inp.login, inp.user, inp.namespaceName, inp.perm)
      return grantNamespacePermission_result()
    catch ex
      exret = grantNamespacePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _grantNamespacePermission
  function _hasNamespacePermission(inp::hasNamespacePermission_args)
    try
      result = hasNamespacePermission(inp.login, inp.user, inp.namespaceName, inp.perm)
      return hasNamespacePermission_result(result)
    catch ex
      exret = hasNamespacePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _hasNamespacePermission
  function _revokeNamespacePermission(inp::revokeNamespacePermission_args)
    try
      revokeNamespacePermission(inp.login, inp.user, inp.namespaceName, inp.perm)
      return revokeNamespacePermission_result()
    catch ex
      exret = revokeNamespacePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _revokeNamespacePermission
  function _createBatchScanner(inp::createBatchScanner_args)
    try
      result = createBatchScanner(inp.login, inp.tableName, inp.options)
      return createBatchScanner_result(result)
    catch ex
      exret = createBatchScanner_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createBatchScanner
  function _createScanner(inp::createScanner_args)
    try
      result = createScanner(inp.login, inp.tableName, inp.options)
      return createScanner_result(result)
    catch ex
      exret = createScanner_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createScanner
  function _hasNext(inp::hasNext_args)
    try
      result = hasNext(inp.scanner)
      return hasNext_result(result)
    catch ex
      exret = hasNext_result()
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch1, ex); return exret)
      rethrow()
    end # try
  end #function _hasNext
  function _nextEntry(inp::nextEntry_args)
    try
      result = nextEntry(inp.scanner)
      return nextEntry_result(result)
    catch ex
      exret = nextEntry_result()
      isa(ex, NoMoreEntriesException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _nextEntry
  function _nextK(inp::nextK_args)
    try
      result = nextK(inp.scanner, inp.k)
      return nextK_result(result)
    catch ex
      exret = nextK_result()
      isa(ex, NoMoreEntriesException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _nextK
  function _closeScanner(inp::closeScanner_args)
    try
      closeScanner(inp.scanner)
      return closeScanner_result()
    catch ex
      exret = closeScanner_result()
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch1, ex); return exret)
      rethrow()
    end # try
  end #function _closeScanner
  function _updateAndFlush(inp::updateAndFlush_args)
    try
      updateAndFlush(inp.login, inp.tableName, inp.cells)
      return updateAndFlush_result()
    catch ex
      exret = updateAndFlush_result()
      isa(ex, AccumuloException) && (set_field!(exret, :outch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, MutationsRejectedException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _updateAndFlush
  function _createWriter(inp::createWriter_args)
    try
      result = createWriter(inp.login, inp.tableName, inp.opts)
      return createWriter_result(result)
    catch ex
      exret = createWriter_result()
      isa(ex, AccumuloException) && (set_field!(exret, :outch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createWriter
  _update(inp::update_args) = (update(); nothing)
  function _flush(inp::flush_args)
    try
      flush(inp.writer)
      return flush_result()
    catch ex
      exret = flush_result()
      isa(ex, UnknownWriter) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, MutationsRejectedException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _flush
  function _closeWriter(inp::closeWriter_args)
    try
      closeWriter(inp.writer)
      return closeWriter_result()
    catch ex
      exret = closeWriter_result()
      isa(ex, UnknownWriter) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, MutationsRejectedException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _closeWriter
  function _updateRowConditionally(inp::updateRowConditionally_args)
    try
      result = updateRowConditionally(inp.login, inp.tableName, inp.row, inp.updates)
      return updateRowConditionally_result(result)
    catch ex
      exret = updateRowConditionally_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _updateRowConditionally
  function _createConditionalWriter(inp::createConditionalWriter_args)
    try
      result = createConditionalWriter(inp.login, inp.tableName, inp.options)
      return createConditionalWriter_result(result)
    catch ex
      exret = createConditionalWriter_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createConditionalWriter
  function _updateRowsConditionally(inp::updateRowsConditionally_args)
    try
      result = updateRowsConditionally(inp.conditionalWriter, inp.updates)
      return updateRowsConditionally_result(result)
    catch ex
      exret = updateRowsConditionally_result()
      isa(ex, UnknownWriter) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _updateRowsConditionally
  _closeConditionalWriter(inp::closeConditionalWriter_args) = (closeConditionalWriter(); closeConditionalWriter_result())
  _getRowRange(inp::getRowRange_args) = getRowRange_result(getRowRange(inp.row))
  _getFollowing(inp::getFollowing_args) = getFollowing_result(getFollowing(inp.key, inp.part))
  _systemNamespace(inp::systemNamespace_args) = systemNamespace_result(systemNamespace())
  _defaultNamespace(inp::defaultNamespace_args) = defaultNamespace_result(defaultNamespace())
  function _listNamespaces(inp::listNamespaces_args)
    try
      result = listNamespaces(inp.login)
      return listNamespaces_result(result)
    catch ex
      exret = listNamespaces_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _listNamespaces
  function _namespaceExists(inp::namespaceExists_args)
    try
      result = namespaceExists(inp.login, inp.namespaceName)
      return namespaceExists_result(result)
    catch ex
      exret = namespaceExists_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _namespaceExists
  function _createNamespace(inp::createNamespace_args)
    try
      createNamespace(inp.login, inp.namespaceName)
      return createNamespace_result()
    catch ex
      exret = createNamespace_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceExistsException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createNamespace
  function _deleteNamespace(inp::deleteNamespace_args)
    try
      deleteNamespace(inp.login, inp.namespaceName)
      return deleteNamespace_result()
    catch ex
      exret = deleteNamespace_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, NamespaceNotEmptyException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _deleteNamespace
  function _renameNamespace(inp::renameNamespace_args)
    try
      renameNamespace(inp.login, inp.oldNamespaceName, inp.newNamespaceName)
      return renameNamespace_result()
    catch ex
      exret = renameNamespace_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, NamespaceExistsException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _renameNamespace
  function _setNamespaceProperty(inp::setNamespaceProperty_args)
    try
      setNamespaceProperty(inp.login, inp.namespaceName, inp.property, inp.value)
      return setNamespaceProperty_result()
    catch ex
      exret = setNamespaceProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _setNamespaceProperty
  function _removeNamespaceProperty(inp::removeNamespaceProperty_args)
    try
      removeNamespaceProperty(inp.login, inp.namespaceName, inp.property)
      return removeNamespaceProperty_result()
    catch ex
      exret = removeNamespaceProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeNamespaceProperty
  function _getNamespaceProperties(inp::getNamespaceProperties_args)
    try
      result = getNamespaceProperties(inp.login, inp.namespaceName)
      return getNamespaceProperties_result(result)
    catch ex
      exret = getNamespaceProperties_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getNamespaceProperties
  function _namespaceIdMap(inp::namespaceIdMap_args)
    try
      result = namespaceIdMap(inp.login)
      return namespaceIdMap_result(result)
    catch ex
      exret = namespaceIdMap_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _namespaceIdMap
  function _attachNamespaceIterator(inp::attachNamespaceIterator_args)
    try
      attachNamespaceIterator(inp.login, inp.namespaceName, inp.setting, inp.scopes)
      return attachNamespaceIterator_result()
    catch ex
      exret = attachNamespaceIterator_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _attachNamespaceIterator
  function _removeNamespaceIterator(inp::removeNamespaceIterator_args)
    try
      removeNamespaceIterator(inp.login, inp.namespaceName, inp.name, inp.scopes)
      return removeNamespaceIterator_result()
    catch ex
      exret = removeNamespaceIterator_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeNamespaceIterator
  function _getNamespaceIteratorSetting(inp::getNamespaceIteratorSetting_args)
    try
      result = getNamespaceIteratorSetting(inp.login, inp.namespaceName, inp.name, inp.scope)
      return getNamespaceIteratorSetting_result(result)
    catch ex
      exret = getNamespaceIteratorSetting_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getNamespaceIteratorSetting
  function _listNamespaceIterators(inp::listNamespaceIterators_args)
    try
      result = listNamespaceIterators(inp.login, inp.namespaceName)
      return listNamespaceIterators_result(result)
    catch ex
      exret = listNamespaceIterators_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listNamespaceIterators
  function _checkNamespaceIteratorConflicts(inp::checkNamespaceIteratorConflicts_args)
    try
      checkNamespaceIteratorConflicts(inp.login, inp.namespaceName, inp.setting, inp.scopes)
      return checkNamespaceIteratorConflicts_result()
    catch ex
      exret = checkNamespaceIteratorConflicts_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _checkNamespaceIteratorConflicts
  function _addNamespaceConstraint(inp::addNamespaceConstraint_args)
    try
      result = addNamespaceConstraint(inp.login, inp.namespaceName, inp.constraintClassName)
      return addNamespaceConstraint_result(result)
    catch ex
      exret = addNamespaceConstraint_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _addNamespaceConstraint
  function _removeNamespaceConstraint(inp::removeNamespaceConstraint_args)
    try
      removeNamespaceConstraint(inp.login, inp.namespaceName, inp.id)
      return removeNamespaceConstraint_result()
    catch ex
      exret = removeNamespaceConstraint_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeNamespaceConstraint
  function _listNamespaceConstraints(inp::listNamespaceConstraints_args)
    try
      result = listNamespaceConstraints(inp.login, inp.namespaceName)
      return listNamespaceConstraints_result(result)
    catch ex
      exret = listNamespaceConstraints_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listNamespaceConstraints
  function _testNamespaceClassLoad(inp::testNamespaceClassLoad_args)
    try
      result = testNamespaceClassLoad(inp.login, inp.namespaceName, inp.className, inp.asTypeName)
      return testNamespaceClassLoad_result(result)
    catch ex
      exret = testNamespaceClassLoad_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, NamespaceNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _testNamespaceClassLoad
end # type AccumuloProxyProcessor
process(p::AccumuloProxyProcessor, inp::TProtocol, outp::TProtocol) = process(p.tp, inp, outp)
distribute(p::AccumuloProxyProcessor) = distribute(p.tp)


# Server side methods to be defined by user:
# function login(principal::String, loginProperties::Dict{String,String})
#     # returns Vector{UInt8}
#     # throws ouch2::AccumuloSecurityException
# function addConstraint(login::Vector{UInt8}, tableName::String, constraintClassName::String)
#     # returns Int32
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function addSplits(login::Vector{UInt8}, tableName::String, splits::Set{Vector{UInt8}})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function attachIterator(login::Vector{UInt8}, tableName::String, setting::IteratorSetting, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::AccumuloException
#     # throws ouch3::TableNotFoundException
# function checkIteratorConflicts(login::Vector{UInt8}, tableName::String, setting::IteratorSetting, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::AccumuloException
#     # throws ouch3::TableNotFoundException
# function clearLocatorCache(login::Vector{UInt8}, tableName::String)
#     # returns nothing
#     # throws ouch1::TableNotFoundException
# function cloneTable(login::Vector{UInt8}, tableName::String, newTableName::String, flush::Bool, propertiesToSet::Dict{String,String}, propertiesToExclude::Set{String})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
#     # throws ouch4::TableExistsException
# function compactTable(login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, iterators::Vector{IteratorSetting}, flush::Bool, wait::Bool, compactionStrategy::CompactionStrategyConfig)
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::TableNotFoundException
#     # throws ouch3::AccumuloException
# function cancelCompaction(login::Vector{UInt8}, tableName::String)
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::TableNotFoundException
#     # throws ouch3::AccumuloException
# function createTable(login::Vector{UInt8}, tableName::String, versioningIter::Bool, _type::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableExistsException
# function deleteTable(login::Vector{UInt8}, tableName::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function deleteRows(login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function exportTable(login::Vector{UInt8}, tableName::String, exportDir::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function flushTable(login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, wait::Bool)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getDiskUsage(login::Vector{UInt8}, tables::Set{String})
#     # returns Vector{DiskUsage}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getLocalityGroups(login::Vector{UInt8}, tableName::String)
#     # returns Dict{String,Set{String}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getIteratorSetting(login::Vector{UInt8}, tableName::String, iteratorName::String, scope::Int32)
#     # returns IteratorSetting
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getMaxRow(login::Vector{UInt8}, tableName::String, auths::Set{Vector{UInt8}}, startRow::Vector{UInt8}, startInclusive::Bool, endRow::Vector{UInt8}, endInclusive::Bool)
#     # returns Vector{UInt8}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getTableProperties(login::Vector{UInt8}, tableName::String)
#     # returns Dict{String,String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function importDirectory(login::Vector{UInt8}, tableName::String, importDir::String, failureDir::String, setTime::Bool)
#     # returns nothing
#     # throws ouch1::TableNotFoundException
#     # throws ouch3::AccumuloException
#     # throws ouch4::AccumuloSecurityException
# function importTable(login::Vector{UInt8}, tableName::String, importDir::String)
#     # returns nothing
#     # throws ouch1::TableExistsException
#     # throws ouch2::AccumuloException
#     # throws ouch3::AccumuloSecurityException
# function listSplits(login::Vector{UInt8}, tableName::String, maxSplits::Int32)
#     # returns Vector{Vector{UInt8}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function listTables(login::Vector{UInt8})
#     # returns Set{String}
# function listIterators(login::Vector{UInt8}, tableName::String)
#     # returns Dict{String,Set{Int32}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function listConstraints(login::Vector{UInt8}, tableName::String)
#     # returns Dict{String,Int32}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function mergeTablets(login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function offlineTable(login::Vector{UInt8}, tableName::String, wait::Bool)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function onlineTable(login::Vector{UInt8}, tableName::String, wait::Bool)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function removeConstraint(login::Vector{UInt8}, tableName::String, constraint::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function removeIterator(login::Vector{UInt8}, tableName::String, iterName::String, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function removeTableProperty(login::Vector{UInt8}, tableName::String, property::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function renameTable(login::Vector{UInt8}, oldTableName::String, newTableName::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
#     # throws ouch4::TableExistsException
# function setLocalityGroups(login::Vector{UInt8}, tableName::String, groups::Dict{String,Set{String}})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function setTableProperty(login::Vector{UInt8}, tableName::String, property::String, value::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function splitRangeByTablets(login::Vector{UInt8}, tableName::String, range::Range, maxSplits::Int32)
#     # returns Set{Range}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function tableExists(login::Vector{UInt8}, tableName::String)
#     # returns Bool
# function tableIdMap(login::Vector{UInt8})
#     # returns Dict{String,String}
# function testTableClassLoad(login::Vector{UInt8}, tableName::String, className::String, asTypeName::String)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function pingTabletServer(login::Vector{UInt8}, tserver::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getActiveScans(login::Vector{UInt8}, tserver::String)
#     # returns Vector{ActiveScan}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getActiveCompactions(login::Vector{UInt8}, tserver::String)
#     # returns Vector{ActiveCompaction}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getSiteConfiguration(login::Vector{UInt8})
#     # returns Dict{String,String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getSystemConfiguration(login::Vector{UInt8})
#     # returns Dict{String,String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getTabletServers(login::Vector{UInt8})
#     # returns Vector{String}
# function removeProperty(login::Vector{UInt8}, property::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function setProperty(login::Vector{UInt8}, property::String, value::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function testClassLoad(login::Vector{UInt8}, className::String, asTypeName::String)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function authenticateUser(login::Vector{UInt8}, user::String, properties::Dict{String,String})
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function changeUserAuthorizations(login::Vector{UInt8}, user::String, authorizations::Set{Vector{UInt8}})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function changeLocalUserPassword(login::Vector{UInt8}, user::String, password::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function createLocalUser(login::Vector{UInt8}, user::String, password::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function dropLocalUser(login::Vector{UInt8}, user::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getUserAuthorizations(login::Vector{UInt8}, user::String)
#     # returns Vector{Vector{UInt8}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function grantSystemPermission(login::Vector{UInt8}, user::String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function grantTablePermission(login::Vector{UInt8}, user::String, table::String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function hasSystemPermission(login::Vector{UInt8}, user::String, perm::Int32)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function hasTablePermission(login::Vector{UInt8}, user::String, table::String, perm::Int32)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function listLocalUsers(login::Vector{UInt8})
#     # returns Set{String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function revokeSystemPermission(login::Vector{UInt8}, user::String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function revokeTablePermission(login::Vector{UInt8}, user::String, table::String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function grantNamespacePermission(login::Vector{UInt8}, user::String, namespaceName::String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function hasNamespacePermission(login::Vector{UInt8}, user::String, namespaceName::String, perm::Int32)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function revokeNamespacePermission(login::Vector{UInt8}, user::String, namespaceName::String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function createBatchScanner(login::Vector{UInt8}, tableName::String, options::BatchScanOptions)
#     # returns String
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function createScanner(login::Vector{UInt8}, tableName::String, options::ScanOptions)
#     # returns String
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function hasNext(scanner::String)
#     # returns Bool
#     # throws ouch1::UnknownScanner
# function nextEntry(scanner::String)
#     # returns KeyValueAndPeek
#     # throws ouch1::NoMoreEntriesException
#     # throws ouch2::UnknownScanner
#     # throws ouch3::AccumuloSecurityException
# function nextK(scanner::String, k::Int32)
#     # returns ScanResult
#     # throws ouch1::NoMoreEntriesException
#     # throws ouch2::UnknownScanner
#     # throws ouch3::AccumuloSecurityException
# function closeScanner(scanner::String)
#     # returns nothing
#     # throws ouch1::UnknownScanner
# function updateAndFlush(login::Vector{UInt8}, tableName::String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
#     # returns nothing
#     # throws outch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
#     # throws ouch4::MutationsRejectedException
# function createWriter(login::Vector{UInt8}, tableName::String, opts::WriterOptions)
#     # returns String
#     # throws outch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function update(writer::String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
#     # returns nothing
# function flush(writer::String)
#     # returns nothing
#     # throws ouch1::UnknownWriter
#     # throws ouch2::MutationsRejectedException
# function closeWriter(writer::String)
#     # returns nothing
#     # throws ouch1::UnknownWriter
#     # throws ouch2::MutationsRejectedException
# function updateRowConditionally(login::Vector{UInt8}, tableName::String, row::Vector{UInt8}, updates::ConditionalUpdates)
#     # returns Int32
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function createConditionalWriter(login::Vector{UInt8}, tableName::String, options::ConditionalWriterOptions)
#     # returns String
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function updateRowsConditionally(conditionalWriter::String, updates::Dict{Vector{UInt8},ConditionalUpdates})
#     # returns Dict{Vector{UInt8},Int32}
#     # throws ouch1::UnknownWriter
#     # throws ouch2::AccumuloException
#     # throws ouch3::AccumuloSecurityException
# function closeConditionalWriter(conditionalWriter::String)
#     # returns nothing
# function getRowRange(row::Vector{UInt8})
#     # returns Range
# function getFollowing(key::Key, part::Int32)
#     # returns Key
# function systemNamespace()
#     # returns String
# function defaultNamespace()
#     # returns String
# function listNamespaces(login::Vector{UInt8})
#     # returns Vector{String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function namespaceExists(login::Vector{UInt8}, namespaceName::String)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function createNamespace(login::Vector{UInt8}, namespaceName::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceExistsException
# function deleteNamespace(login::Vector{UInt8}, namespaceName::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
#     # throws ouch4::NamespaceNotEmptyException
# function renameNamespace(login::Vector{UInt8}, oldNamespaceName::String, newNamespaceName::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
#     # throws ouch4::NamespaceExistsException
# function setNamespaceProperty(login::Vector{UInt8}, namespaceName::String, property::String, value::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function removeNamespaceProperty(login::Vector{UInt8}, namespaceName::String, property::String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function getNamespaceProperties(login::Vector{UInt8}, namespaceName::String)
#     # returns Dict{String,String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function namespaceIdMap(login::Vector{UInt8})
#     # returns Dict{String,String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function attachNamespaceIterator(login::Vector{UInt8}, namespaceName::String, setting::IteratorSetting, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function removeNamespaceIterator(login::Vector{UInt8}, namespaceName::String, name::String, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function getNamespaceIteratorSetting(login::Vector{UInt8}, namespaceName::String, name::String, scope::Int32)
#     # returns IteratorSetting
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function listNamespaceIterators(login::Vector{UInt8}, namespaceName::String)
#     # returns Dict{String,Set{Int32}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function checkNamespaceIteratorConflicts(login::Vector{UInt8}, namespaceName::String, setting::IteratorSetting, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function addNamespaceConstraint(login::Vector{UInt8}, namespaceName::String, constraintClassName::String)
#     # returns Int32
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function removeNamespaceConstraint(login::Vector{UInt8}, namespaceName::String, id::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function listNamespaceConstraints(login::Vector{UInt8}, namespaceName::String)
#     # returns Dict{String,Int32}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException
# function testNamespaceClassLoad(login::Vector{UInt8}, namespaceName::String, className::String, asTypeName::String)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::NamespaceNotFoundException


# Client implementation for AccumuloProxy service
type AccumuloProxyClient <: AccumuloProxyClientBase
  p::TProtocol
  seqid::Int32
  AccumuloProxyClient(p::TProtocol) = new(p, 0)
end # type AccumuloProxyClient

# Client callable method for login
function login(c::AccumuloProxyClientBase, principal::String, loginProperties::Dict{String,String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "login", Thrift.MessageType.CALL, c.seqid)
  inp = login_args()
  Thrift.set_field!(inp, :principal, principal)
  Thrift.set_field!(inp, :loginProperties, loginProperties)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, login_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function login

# Client callable method for addConstraint
function addConstraint(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, constraintClassName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "addConstraint", Thrift.MessageType.CALL, c.seqid)
  inp = addConstraint_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :constraintClassName, constraintClassName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, addConstraint_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function addConstraint

# Client callable method for addSplits
function addSplits(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, splits::Set{Vector{UInt8}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "addSplits", Thrift.MessageType.CALL, c.seqid)
  inp = addSplits_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :splits, splits)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, addSplits_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function addSplits

# Client callable method for attachIterator
function attachIterator(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, setting::IteratorSetting, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "attachIterator", Thrift.MessageType.CALL, c.seqid)
  inp = attachIterator_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :setting, setting)
  Thrift.set_field!(inp, :scopes, scopes)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, attachIterator_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function attachIterator

# Client callable method for checkIteratorConflicts
function checkIteratorConflicts(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, setting::IteratorSetting, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "checkIteratorConflicts", Thrift.MessageType.CALL, c.seqid)
  inp = checkIteratorConflicts_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :setting, setting)
  Thrift.set_field!(inp, :scopes, scopes)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, checkIteratorConflicts_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function checkIteratorConflicts

# Client callable method for clearLocatorCache
function clearLocatorCache(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "clearLocatorCache", Thrift.MessageType.CALL, c.seqid)
  inp = clearLocatorCache_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, clearLocatorCache_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  nothing
end # function clearLocatorCache

# Client callable method for cloneTable
function cloneTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, newTableName::String, flush::Bool, propertiesToSet::Dict{String,String}, propertiesToExclude::Set{String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "cloneTable", Thrift.MessageType.CALL, c.seqid)
  inp = cloneTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :newTableName, newTableName)
  Thrift.set_field!(inp, :flush, flush)
  Thrift.set_field!(inp, :propertiesToSet, propertiesToSet)
  Thrift.set_field!(inp, :propertiesToExclude, propertiesToExclude)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, cloneTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :ouch4) && throw(Thrift.get_field(outp, :ouch4))
  nothing
end # function cloneTable

# Client callable method for compactTable
function compactTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, iterators::Vector{IteratorSetting}, flush::Bool, wait::Bool, compactionStrategy::CompactionStrategyConfig)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "compactTable", Thrift.MessageType.CALL, c.seqid)
  inp = compactTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :startRow, startRow)
  Thrift.set_field!(inp, :endRow, endRow)
  Thrift.set_field!(inp, :iterators, iterators)
  Thrift.set_field!(inp, :flush, flush)
  Thrift.set_field!(inp, :wait, wait)
  Thrift.set_field!(inp, :compactionStrategy, compactionStrategy)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, compactTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function compactTable

# Client callable method for cancelCompaction
function cancelCompaction(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "cancelCompaction", Thrift.MessageType.CALL, c.seqid)
  inp = cancelCompaction_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, cancelCompaction_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function cancelCompaction

# Client callable method for createTable
function createTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, versioningIter::Bool, _type::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "createTable", Thrift.MessageType.CALL, c.seqid)
  inp = createTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :versioningIter, versioningIter)
  Thrift.set_field!(inp, :_type, _type)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, createTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function createTable

# Client callable method for deleteTable
function deleteTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "deleteTable", Thrift.MessageType.CALL, c.seqid)
  inp = deleteTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, deleteTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function deleteTable

# Client callable method for deleteRows
function deleteRows(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "deleteRows", Thrift.MessageType.CALL, c.seqid)
  inp = deleteRows_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :startRow, startRow)
  Thrift.set_field!(inp, :endRow, endRow)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, deleteRows_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function deleteRows

# Client callable method for exportTable
function exportTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, exportDir::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "exportTable", Thrift.MessageType.CALL, c.seqid)
  inp = exportTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :exportDir, exportDir)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, exportTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function exportTable

# Client callable method for flushTable
function flushTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, wait::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "flushTable", Thrift.MessageType.CALL, c.seqid)
  inp = flushTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :startRow, startRow)
  Thrift.set_field!(inp, :endRow, endRow)
  Thrift.set_field!(inp, :wait, wait)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, flushTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function flushTable

# Client callable method for getDiskUsage
function getDiskUsage(c::AccumuloProxyClientBase, login::Vector{UInt8}, tables::Set{String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getDiskUsage", Thrift.MessageType.CALL, c.seqid)
  inp = getDiskUsage_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tables, tables)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getDiskUsage_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getDiskUsage

# Client callable method for getLocalityGroups
function getLocalityGroups(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getLocalityGroups", Thrift.MessageType.CALL, c.seqid)
  inp = getLocalityGroups_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getLocalityGroups_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getLocalityGroups

# Client callable method for getIteratorSetting
function getIteratorSetting(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, iteratorName::String, scope::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getIteratorSetting", Thrift.MessageType.CALL, c.seqid)
  inp = getIteratorSetting_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :iteratorName, iteratorName)
  Thrift.set_field!(inp, :scope, scope)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getIteratorSetting_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getIteratorSetting

# Client callable method for getMaxRow
function getMaxRow(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, auths::Set{Vector{UInt8}}, startRow::Vector{UInt8}, startInclusive::Bool, endRow::Vector{UInt8}, endInclusive::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getMaxRow", Thrift.MessageType.CALL, c.seqid)
  inp = getMaxRow_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :auths, auths)
  Thrift.set_field!(inp, :startRow, startRow)
  Thrift.set_field!(inp, :startInclusive, startInclusive)
  Thrift.set_field!(inp, :endRow, endRow)
  Thrift.set_field!(inp, :endInclusive, endInclusive)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getMaxRow_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getMaxRow

# Client callable method for getTableProperties
function getTableProperties(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getTableProperties", Thrift.MessageType.CALL, c.seqid)
  inp = getTableProperties_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getTableProperties_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getTableProperties

# Client callable method for importDirectory
function importDirectory(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, importDir::String, failureDir::String, setTime::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "importDirectory", Thrift.MessageType.CALL, c.seqid)
  inp = importDirectory_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :importDir, importDir)
  Thrift.set_field!(inp, :failureDir, failureDir)
  Thrift.set_field!(inp, :setTime, setTime)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, importDirectory_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :ouch4) && throw(Thrift.get_field(outp, :ouch4))
  nothing
end # function importDirectory

# Client callable method for importTable
function importTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, importDir::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "importTable", Thrift.MessageType.CALL, c.seqid)
  inp = importTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :importDir, importDir)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, importTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function importTable

# Client callable method for listSplits
function listSplits(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, maxSplits::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listSplits", Thrift.MessageType.CALL, c.seqid)
  inp = listSplits_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :maxSplits, maxSplits)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listSplits_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listSplits

# Client callable method for listTables
function listTables(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listTables", Thrift.MessageType.CALL, c.seqid)
  inp = listTables_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listTables_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listTables

# Client callable method for listIterators
function listIterators(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listIterators", Thrift.MessageType.CALL, c.seqid)
  inp = listIterators_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listIterators_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listIterators

# Client callable method for listConstraints
function listConstraints(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listConstraints", Thrift.MessageType.CALL, c.seqid)
  inp = listConstraints_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listConstraints_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listConstraints

# Client callable method for mergeTablets
function mergeTablets(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "mergeTablets", Thrift.MessageType.CALL, c.seqid)
  inp = mergeTablets_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :startRow, startRow)
  Thrift.set_field!(inp, :endRow, endRow)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, mergeTablets_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function mergeTablets

# Client callable method for offlineTable
function offlineTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, wait::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "offlineTable", Thrift.MessageType.CALL, c.seqid)
  inp = offlineTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :wait, wait)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, offlineTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function offlineTable

# Client callable method for onlineTable
function onlineTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, wait::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "onlineTable", Thrift.MessageType.CALL, c.seqid)
  inp = onlineTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :wait, wait)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, onlineTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function onlineTable

# Client callable method for removeConstraint
function removeConstraint(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, constraint::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "removeConstraint", Thrift.MessageType.CALL, c.seqid)
  inp = removeConstraint_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :constraint, constraint)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, removeConstraint_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function removeConstraint

# Client callable method for removeIterator
function removeIterator(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, iterName::String, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "removeIterator", Thrift.MessageType.CALL, c.seqid)
  inp = removeIterator_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :iterName, iterName)
  Thrift.set_field!(inp, :scopes, scopes)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, removeIterator_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function removeIterator

# Client callable method for removeTableProperty
function removeTableProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, property::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "removeTableProperty", Thrift.MessageType.CALL, c.seqid)
  inp = removeTableProperty_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :property, property)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, removeTableProperty_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function removeTableProperty

# Client callable method for renameTable
function renameTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, oldTableName::String, newTableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "renameTable", Thrift.MessageType.CALL, c.seqid)
  inp = renameTable_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :oldTableName, oldTableName)
  Thrift.set_field!(inp, :newTableName, newTableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, renameTable_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :ouch4) && throw(Thrift.get_field(outp, :ouch4))
  nothing
end # function renameTable

# Client callable method for setLocalityGroups
function setLocalityGroups(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, groups::Dict{String,Set{String}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "setLocalityGroups", Thrift.MessageType.CALL, c.seqid)
  inp = setLocalityGroups_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :groups, groups)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, setLocalityGroups_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function setLocalityGroups

# Client callable method for setTableProperty
function setTableProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, property::String, value::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "setTableProperty", Thrift.MessageType.CALL, c.seqid)
  inp = setTableProperty_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :property, property)
  Thrift.set_field!(inp, :value, value)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, setTableProperty_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function setTableProperty

# Client callable method for splitRangeByTablets
function splitRangeByTablets(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, range::Range, maxSplits::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "splitRangeByTablets", Thrift.MessageType.CALL, c.seqid)
  inp = splitRangeByTablets_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :range, range)
  Thrift.set_field!(inp, :maxSplits, maxSplits)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, splitRangeByTablets_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function splitRangeByTablets

# Client callable method for tableExists
function tableExists(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "tableExists", Thrift.MessageType.CALL, c.seqid)
  inp = tableExists_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, tableExists_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function tableExists

# Client callable method for tableIdMap
function tableIdMap(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "tableIdMap", Thrift.MessageType.CALL, c.seqid)
  inp = tableIdMap_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, tableIdMap_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function tableIdMap

# Client callable method for testTableClassLoad
function testTableClassLoad(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, className::String, asTypeName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "testTableClassLoad", Thrift.MessageType.CALL, c.seqid)
  inp = testTableClassLoad_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :className, className)
  Thrift.set_field!(inp, :asTypeName, asTypeName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, testTableClassLoad_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function testTableClassLoad

# Client callable method for pingTabletServer
function pingTabletServer(c::AccumuloProxyClientBase, login::Vector{UInt8}, tserver::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "pingTabletServer", Thrift.MessageType.CALL, c.seqid)
  inp = pingTabletServer_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tserver, tserver)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, pingTabletServer_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function pingTabletServer

# Client callable method for getActiveScans
function getActiveScans(c::AccumuloProxyClientBase, login::Vector{UInt8}, tserver::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getActiveScans", Thrift.MessageType.CALL, c.seqid)
  inp = getActiveScans_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tserver, tserver)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getActiveScans_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getActiveScans

# Client callable method for getActiveCompactions
function getActiveCompactions(c::AccumuloProxyClientBase, login::Vector{UInt8}, tserver::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getActiveCompactions", Thrift.MessageType.CALL, c.seqid)
  inp = getActiveCompactions_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tserver, tserver)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getActiveCompactions_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getActiveCompactions

# Client callable method for getSiteConfiguration
function getSiteConfiguration(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getSiteConfiguration", Thrift.MessageType.CALL, c.seqid)
  inp = getSiteConfiguration_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getSiteConfiguration_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getSiteConfiguration

# Client callable method for getSystemConfiguration
function getSystemConfiguration(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getSystemConfiguration", Thrift.MessageType.CALL, c.seqid)
  inp = getSystemConfiguration_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getSystemConfiguration_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getSystemConfiguration

# Client callable method for getTabletServers
function getTabletServers(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getTabletServers", Thrift.MessageType.CALL, c.seqid)
  inp = getTabletServers_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getTabletServers_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getTabletServers

# Client callable method for removeProperty
function removeProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, property::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "removeProperty", Thrift.MessageType.CALL, c.seqid)
  inp = removeProperty_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :property, property)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, removeProperty_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function removeProperty

# Client callable method for setProperty
function setProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, property::String, value::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "setProperty", Thrift.MessageType.CALL, c.seqid)
  inp = setProperty_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :property, property)
  Thrift.set_field!(inp, :value, value)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, setProperty_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function setProperty

# Client callable method for testClassLoad
function testClassLoad(c::AccumuloProxyClientBase, login::Vector{UInt8}, className::String, asTypeName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "testClassLoad", Thrift.MessageType.CALL, c.seqid)
  inp = testClassLoad_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :className, className)
  Thrift.set_field!(inp, :asTypeName, asTypeName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, testClassLoad_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function testClassLoad

# Client callable method for authenticateUser
function authenticateUser(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, properties::Dict{String,String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "authenticateUser", Thrift.MessageType.CALL, c.seqid)
  inp = authenticateUser_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :properties, properties)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, authenticateUser_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function authenticateUser

# Client callable method for changeUserAuthorizations
function changeUserAuthorizations(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, authorizations::Set{Vector{UInt8}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "changeUserAuthorizations", Thrift.MessageType.CALL, c.seqid)
  inp = changeUserAuthorizations_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :authorizations, authorizations)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, changeUserAuthorizations_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function changeUserAuthorizations

# Client callable method for changeLocalUserPassword
function changeLocalUserPassword(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, password::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "changeLocalUserPassword", Thrift.MessageType.CALL, c.seqid)
  inp = changeLocalUserPassword_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :password, password)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, changeLocalUserPassword_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function changeLocalUserPassword

# Client callable method for createLocalUser
function createLocalUser(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, password::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "createLocalUser", Thrift.MessageType.CALL, c.seqid)
  inp = createLocalUser_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :password, password)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, createLocalUser_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function createLocalUser

# Client callable method for dropLocalUser
function dropLocalUser(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "dropLocalUser", Thrift.MessageType.CALL, c.seqid)
  inp = dropLocalUser_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, dropLocalUser_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function dropLocalUser

# Client callable method for getUserAuthorizations
function getUserAuthorizations(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getUserAuthorizations", Thrift.MessageType.CALL, c.seqid)
  inp = getUserAuthorizations_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getUserAuthorizations_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getUserAuthorizations

# Client callable method for grantSystemPermission
function grantSystemPermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "grantSystemPermission", Thrift.MessageType.CALL, c.seqid)
  inp = grantSystemPermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, grantSystemPermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function grantSystemPermission

# Client callable method for grantTablePermission
function grantTablePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, table::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "grantTablePermission", Thrift.MessageType.CALL, c.seqid)
  inp = grantTablePermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :table, table)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, grantTablePermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function grantTablePermission

# Client callable method for hasSystemPermission
function hasSystemPermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "hasSystemPermission", Thrift.MessageType.CALL, c.seqid)
  inp = hasSystemPermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, hasSystemPermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function hasSystemPermission

# Client callable method for hasTablePermission
function hasTablePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, table::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "hasTablePermission", Thrift.MessageType.CALL, c.seqid)
  inp = hasTablePermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :table, table)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, hasTablePermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function hasTablePermission

# Client callable method for listLocalUsers
function listLocalUsers(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listLocalUsers", Thrift.MessageType.CALL, c.seqid)
  inp = listLocalUsers_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listLocalUsers_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listLocalUsers

# Client callable method for revokeSystemPermission
function revokeSystemPermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "revokeSystemPermission", Thrift.MessageType.CALL, c.seqid)
  inp = revokeSystemPermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, revokeSystemPermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function revokeSystemPermission

# Client callable method for revokeTablePermission
function revokeTablePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, table::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "revokeTablePermission", Thrift.MessageType.CALL, c.seqid)
  inp = revokeTablePermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :table, table)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, revokeTablePermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function revokeTablePermission

# Client callable method for grantNamespacePermission
function grantNamespacePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, namespaceName::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "grantNamespacePermission", Thrift.MessageType.CALL, c.seqid)
  inp = grantNamespacePermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, grantNamespacePermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function grantNamespacePermission

# Client callable method for hasNamespacePermission
function hasNamespacePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, namespaceName::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "hasNamespacePermission", Thrift.MessageType.CALL, c.seqid)
  inp = hasNamespacePermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, hasNamespacePermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function hasNamespacePermission

# Client callable method for revokeNamespacePermission
function revokeNamespacePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::String, namespaceName::String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "revokeNamespacePermission", Thrift.MessageType.CALL, c.seqid)
  inp = revokeNamespacePermission_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :user, user)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :perm, perm)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, revokeNamespacePermission_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function revokeNamespacePermission

# Client callable method for createBatchScanner
function createBatchScanner(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, options::BatchScanOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "createBatchScanner", Thrift.MessageType.CALL, c.seqid)
  inp = createBatchScanner_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :options, options)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, createBatchScanner_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createBatchScanner

# Client callable method for createScanner
function createScanner(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, options::ScanOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "createScanner", Thrift.MessageType.CALL, c.seqid)
  inp = createScanner_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :options, options)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, createScanner_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createScanner

# Client callable method for hasNext
function hasNext(c::AccumuloProxyClientBase, scanner::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "hasNext", Thrift.MessageType.CALL, c.seqid)
  inp = hasNext_args()
  Thrift.set_field!(inp, :scanner, scanner)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, hasNext_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function hasNext

# Client callable method for nextEntry
function nextEntry(c::AccumuloProxyClientBase, scanner::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "nextEntry", Thrift.MessageType.CALL, c.seqid)
  inp = nextEntry_args()
  Thrift.set_field!(inp, :scanner, scanner)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, nextEntry_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function nextEntry

# Client callable method for nextK
function nextK(c::AccumuloProxyClientBase, scanner::String, k::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "nextK", Thrift.MessageType.CALL, c.seqid)
  inp = nextK_args()
  Thrift.set_field!(inp, :scanner, scanner)
  Thrift.set_field!(inp, :k, k)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, nextK_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function nextK

# Client callable method for closeScanner
function closeScanner(c::AccumuloProxyClientBase, scanner::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "closeScanner", Thrift.MessageType.CALL, c.seqid)
  inp = closeScanner_args()
  Thrift.set_field!(inp, :scanner, scanner)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, closeScanner_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  nothing
end # function closeScanner

# Client callable method for updateAndFlush
function updateAndFlush(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "updateAndFlush", Thrift.MessageType.CALL, c.seqid)
  inp = updateAndFlush_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :cells, cells)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, updateAndFlush_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :outch1) && throw(Thrift.get_field(outp, :outch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :ouch4) && throw(Thrift.get_field(outp, :ouch4))
  nothing
end # function updateAndFlush

# Client callable method for createWriter
function createWriter(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, opts::WriterOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "createWriter", Thrift.MessageType.CALL, c.seqid)
  inp = createWriter_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :opts, opts)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, createWriter_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :outch1) && throw(Thrift.get_field(outp, :outch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createWriter

# Client callable method for update
function update(c::AccumuloProxyClientBase, writer::String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "update", Thrift.MessageType.ONEWAY, c.seqid)
  inp = update_args()
  Thrift.set_field!(inp, :writer, writer)
  Thrift.set_field!(inp, :cells, cells)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  nothing
end # function update

# Client callable method for flush
function flush(c::AccumuloProxyClientBase, writer::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "flush", Thrift.MessageType.CALL, c.seqid)
  inp = flush_args()
  Thrift.set_field!(inp, :writer, writer)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, flush_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function flush

# Client callable method for closeWriter
function closeWriter(c::AccumuloProxyClientBase, writer::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "closeWriter", Thrift.MessageType.CALL, c.seqid)
  inp = closeWriter_args()
  Thrift.set_field!(inp, :writer, writer)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, closeWriter_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  nothing
end # function closeWriter

# Client callable method for updateRowConditionally
function updateRowConditionally(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, row::Vector{UInt8}, updates::ConditionalUpdates)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "updateRowConditionally", Thrift.MessageType.CALL, c.seqid)
  inp = updateRowConditionally_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :row, row)
  Thrift.set_field!(inp, :updates, updates)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, updateRowConditionally_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function updateRowConditionally

# Client callable method for createConditionalWriter
function createConditionalWriter(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::String, options::ConditionalWriterOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "createConditionalWriter", Thrift.MessageType.CALL, c.seqid)
  inp = createConditionalWriter_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :tableName, tableName)
  Thrift.set_field!(inp, :options, options)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, createConditionalWriter_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createConditionalWriter

# Client callable method for updateRowsConditionally
function updateRowsConditionally(c::AccumuloProxyClientBase, conditionalWriter::String, updates::Dict{Vector{UInt8},ConditionalUpdates})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "updateRowsConditionally", Thrift.MessageType.CALL, c.seqid)
  inp = updateRowsConditionally_args()
  Thrift.set_field!(inp, :conditionalWriter, conditionalWriter)
  Thrift.set_field!(inp, :updates, updates)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, updateRowsConditionally_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function updateRowsConditionally

# Client callable method for closeConditionalWriter
function closeConditionalWriter(c::AccumuloProxyClientBase, conditionalWriter::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "closeConditionalWriter", Thrift.MessageType.CALL, c.seqid)
  inp = closeConditionalWriter_args()
  Thrift.set_field!(inp, :conditionalWriter, conditionalWriter)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, closeConditionalWriter_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  nothing
end # function closeConditionalWriter

# Client callable method for getRowRange
function getRowRange(c::AccumuloProxyClientBase, row::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getRowRange", Thrift.MessageType.CALL, c.seqid)
  inp = getRowRange_args()
  Thrift.set_field!(inp, :row, row)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getRowRange_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getRowRange

# Client callable method for getFollowing
function getFollowing(c::AccumuloProxyClientBase, key::Key, part::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getFollowing", Thrift.MessageType.CALL, c.seqid)
  inp = getFollowing_args()
  Thrift.set_field!(inp, :key, key)
  Thrift.set_field!(inp, :part, part)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getFollowing_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getFollowing

# Client callable method for systemNamespace
function systemNamespace(c::AccumuloProxyClientBase)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "systemNamespace", Thrift.MessageType.CALL, c.seqid)
  inp = systemNamespace_args()
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, systemNamespace_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function systemNamespace

# Client callable method for defaultNamespace
function defaultNamespace(c::AccumuloProxyClientBase)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "defaultNamespace", Thrift.MessageType.CALL, c.seqid)
  inp = defaultNamespace_args()
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, defaultNamespace_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function defaultNamespace

# Client callable method for listNamespaces
function listNamespaces(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listNamespaces", Thrift.MessageType.CALL, c.seqid)
  inp = listNamespaces_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listNamespaces_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listNamespaces

# Client callable method for namespaceExists
function namespaceExists(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "namespaceExists", Thrift.MessageType.CALL, c.seqid)
  inp = namespaceExists_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, namespaceExists_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function namespaceExists

# Client callable method for createNamespace
function createNamespace(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "createNamespace", Thrift.MessageType.CALL, c.seqid)
  inp = createNamespace_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, createNamespace_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function createNamespace

# Client callable method for deleteNamespace
function deleteNamespace(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "deleteNamespace", Thrift.MessageType.CALL, c.seqid)
  inp = deleteNamespace_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, deleteNamespace_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :ouch4) && throw(Thrift.get_field(outp, :ouch4))
  nothing
end # function deleteNamespace

# Client callable method for renameNamespace
function renameNamespace(c::AccumuloProxyClientBase, login::Vector{UInt8}, oldNamespaceName::String, newNamespaceName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "renameNamespace", Thrift.MessageType.CALL, c.seqid)
  inp = renameNamespace_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :oldNamespaceName, oldNamespaceName)
  Thrift.set_field!(inp, :newNamespaceName, newNamespaceName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, renameNamespace_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :ouch4) && throw(Thrift.get_field(outp, :ouch4))
  nothing
end # function renameNamespace

# Client callable method for setNamespaceProperty
function setNamespaceProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, property::String, value::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "setNamespaceProperty", Thrift.MessageType.CALL, c.seqid)
  inp = setNamespaceProperty_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :property, property)
  Thrift.set_field!(inp, :value, value)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, setNamespaceProperty_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function setNamespaceProperty

# Client callable method for removeNamespaceProperty
function removeNamespaceProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, property::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "removeNamespaceProperty", Thrift.MessageType.CALL, c.seqid)
  inp = removeNamespaceProperty_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :property, property)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, removeNamespaceProperty_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function removeNamespaceProperty

# Client callable method for getNamespaceProperties
function getNamespaceProperties(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getNamespaceProperties", Thrift.MessageType.CALL, c.seqid)
  inp = getNamespaceProperties_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getNamespaceProperties_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getNamespaceProperties

# Client callable method for namespaceIdMap
function namespaceIdMap(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "namespaceIdMap", Thrift.MessageType.CALL, c.seqid)
  inp = namespaceIdMap_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, namespaceIdMap_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function namespaceIdMap

# Client callable method for attachNamespaceIterator
function attachNamespaceIterator(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, setting::IteratorSetting, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "attachNamespaceIterator", Thrift.MessageType.CALL, c.seqid)
  inp = attachNamespaceIterator_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :setting, setting)
  Thrift.set_field!(inp, :scopes, scopes)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, attachNamespaceIterator_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function attachNamespaceIterator

# Client callable method for removeNamespaceIterator
function removeNamespaceIterator(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, name::String, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "removeNamespaceIterator", Thrift.MessageType.CALL, c.seqid)
  inp = removeNamespaceIterator_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :name, name)
  Thrift.set_field!(inp, :scopes, scopes)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, removeNamespaceIterator_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function removeNamespaceIterator

# Client callable method for getNamespaceIteratorSetting
function getNamespaceIteratorSetting(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, name::String, scope::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "getNamespaceIteratorSetting", Thrift.MessageType.CALL, c.seqid)
  inp = getNamespaceIteratorSetting_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :name, name)
  Thrift.set_field!(inp, :scope, scope)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, getNamespaceIteratorSetting_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getNamespaceIteratorSetting

# Client callable method for listNamespaceIterators
function listNamespaceIterators(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listNamespaceIterators", Thrift.MessageType.CALL, c.seqid)
  inp = listNamespaceIterators_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listNamespaceIterators_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listNamespaceIterators

# Client callable method for checkNamespaceIteratorConflicts
function checkNamespaceIteratorConflicts(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, setting::IteratorSetting, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "checkNamespaceIteratorConflicts", Thrift.MessageType.CALL, c.seqid)
  inp = checkNamespaceIteratorConflicts_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :setting, setting)
  Thrift.set_field!(inp, :scopes, scopes)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, checkNamespaceIteratorConflicts_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function checkNamespaceIteratorConflicts

# Client callable method for addNamespaceConstraint
function addNamespaceConstraint(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, constraintClassName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "addNamespaceConstraint", Thrift.MessageType.CALL, c.seqid)
  inp = addNamespaceConstraint_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :constraintClassName, constraintClassName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, addNamespaceConstraint_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function addNamespaceConstraint

# Client callable method for removeNamespaceConstraint
function removeNamespaceConstraint(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, id::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "removeNamespaceConstraint", Thrift.MessageType.CALL, c.seqid)
  inp = removeNamespaceConstraint_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :id, id)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, removeNamespaceConstraint_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  nothing
end # function removeNamespaceConstraint

# Client callable method for listNamespaceConstraints
function listNamespaceConstraints(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "listNamespaceConstraints", Thrift.MessageType.CALL, c.seqid)
  inp = listNamespaceConstraints_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, listNamespaceConstraints_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listNamespaceConstraints

# Client callable method for testNamespaceClassLoad
function testNamespaceClassLoad(c::AccumuloProxyClientBase, login::Vector{UInt8}, namespaceName::String, className::String, asTypeName::String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "testNamespaceClassLoad", Thrift.MessageType.CALL, c.seqid)
  inp = testNamespaceClassLoad_args()
  Thrift.set_field!(inp, :login, login)
  Thrift.set_field!(inp, :namespaceName, namespaceName)
  Thrift.set_field!(inp, :className, className)
  Thrift.set_field!(inp, :asTypeName, asTypeName)
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, testNamespaceClassLoad_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  Thrift.has_field(outp, :ouch1) && throw(Thrift.get_field(outp, :ouch1))
  Thrift.has_field(outp, :ouch2) && throw(Thrift.get_field(outp, :ouch2))
  Thrift.has_field(outp, :ouch3) && throw(Thrift.get_field(outp, :ouch3))
  Thrift.has_field(outp, :success) && (return Thrift.get_field(outp, :success))
  throw(Thrift.TApplicationException(Thrift.ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function testNamespaceClassLoad

